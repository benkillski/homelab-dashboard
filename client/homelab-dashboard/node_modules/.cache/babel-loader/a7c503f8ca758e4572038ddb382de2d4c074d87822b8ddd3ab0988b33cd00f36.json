{"ast":null,"code":"\"use strict\";\n\nconst xnv = require(\"xml-name-validator\");\nconst attributeUtils = require(\"./attributes\");\nconst {\n  NAMESPACES,\n  VOID_ELEMENTS,\n  NODE_TYPES\n} = require(\"./constants\");\nconst XML_CHAR = /^(\\x09|\\x0A|\\x0D|[\\x20-\\uD7FF]|[\\uE000-\\uFFFD]|(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]))*$/;\nconst PUBID_CHAR = /^(\\x20|\\x0D|\\x0A|[a-zA-Z0-9]|[-'()+,./:=?;!*#@$_%])*$/;\nfunction asciiCaseInsensitiveMatch(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; ++i) {\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction recordNamespaceInformation(element, map, prefixMap) {\n  let defaultNamespaceAttrValue = null;\n  for (let i = 0; i < element.attributes.length; ++i) {\n    const attr = element.attributes[i];\n    if (attr.namespaceURI === NAMESPACES.XMLNS) {\n      if (attr.prefix === null) {\n        defaultNamespaceAttrValue = attr.value;\n        continue;\n      }\n      let namespaceDefinition = attr.value;\n      if (namespaceDefinition === NAMESPACES.XML) {\n        continue;\n      }\n      // This is exactly the other way than the spec says, but that's intended.\n      // All the maps coalesce null to the empty string (explained in the\n      // spec), so instead of doing that every time, just do it once here.\n      if (namespaceDefinition === null) {\n        namespaceDefinition = \"\";\n      }\n      if (namespaceDefinition in map && map[namespaceDefinition].includes(attr.localName)) {\n        continue;\n      }\n      if (!(namespaceDefinition in map)) {\n        map[namespaceDefinition] = [];\n      }\n      map[namespaceDefinition].push(attr.localName);\n      prefixMap[attr.localName] = namespaceDefinition;\n    }\n  }\n  return defaultNamespaceAttrValue;\n}\nfunction serializeDocumentType(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !PUBID_CHAR.test(node.publicId)) {\n    throw new Error(\"Failed to serialize XML: document type node publicId is not well-formed.\");\n  }\n  if (requireWellFormed && (!XML_CHAR.test(node.systemId) || node.systemId.includes('\"') && node.systemId.includes(\"'\"))) {\n    throw new Error(\"Failed to serialize XML: document type node systemId is not well-formed.\");\n  }\n  let markup = `<!DOCTYPE ${node.name}`;\n  if (node.publicId !== \"\") {\n    markup += ` PUBLIC \"${node.publicId}\"`;\n  } else if (node.systemId !== \"\") {\n    markup += \" SYSTEM\";\n  }\n  if (node.systemId !== \"\") {\n    markup += ` \"${node.systemId}\"`;\n  }\n  return markup + \">\";\n}\nfunction serializeProcessingInstruction(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && (node.target.includes(\":\") || asciiCaseInsensitiveMatch(node.target, \"xml\"))) {\n    throw new Error(\"Failed to serialize XML: processing instruction node target is not well-formed.\");\n  }\n  if (requireWellFormed && (!XML_CHAR.test(node.data) || node.data.includes(\"?>\"))) {\n    throw new Error(\"Failed to serialize XML: processing instruction node data is not well-formed.\");\n  }\n  return `<?${node.target} ${node.data}?>`;\n}\nfunction serializeDocument(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (requireWellFormed && node.documentElement === null) {\n    throw new Error(\"Failed to serialize XML: document does not have a document element.\");\n  }\n  let serializedDocument = \"\";\n  for (const child of node.childNodes) {\n    serializedDocument += xmlSerialization(child, namespace, prefixMap, requireWellFormed, refs);\n  }\n  return serializedDocument;\n}\nfunction serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed, refs) {\n  let markup = \"\";\n  for (const child of node.childNodes) {\n    markup += xmlSerialization(child, namespace, prefixMap, requireWellFormed, refs);\n  }\n  return markup;\n}\nfunction serializeText(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: text node data is not well-formed.\");\n  }\n  return node.data.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nfunction serializeComment(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: comment node data is not well-formed.\");\n  }\n  if (requireWellFormed && (node.data.includes(\"--\") || node.data.endsWith(\"-\"))) {\n    throw new Error(\"Failed to serialize XML: found hyphens in illegal places in comment node data.\");\n  }\n  return `<!--${node.data}-->`;\n}\nfunction serializeElement(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (requireWellFormed && (node.localName.includes(\":\") || !xnv.name(node.localName))) {\n    throw new Error(\"Failed to serialize XML: element node localName is not a valid XML name.\");\n  }\n  let markup = \"<\";\n  let qualifiedName = \"\";\n  let skipEndTag = false;\n  let ignoreNamespaceDefinitionAttr = false;\n  const map = Object.assign({}, prefixMap);\n  const localPrefixesMap = Object.create(null);\n  const localDefaultNamespace = recordNamespaceInformation(node, map, localPrefixesMap);\n  let inheritedNs = namespace;\n  const ns = node.namespaceURI;\n  if (inheritedNs === ns) {\n    if (localDefaultNamespace !== null) {\n      ignoreNamespaceDefinitionAttr = true;\n    }\n    if (ns === NAMESPACES.XML) {\n      qualifiedName = \"xml:\" + node.localName;\n    } else {\n      qualifiedName = node.localName;\n    }\n    markup += qualifiedName;\n  } else {\n    let {\n      prefix\n    } = node;\n    let candidatePrefix = attributeUtils.preferredPrefixString(map, ns, prefix);\n    if (prefix === \"xmlns\") {\n      if (requireWellFormed) {\n        throw new Error(\"Failed to serialize XML: element nodes can't have a prefix of \\\"xmlns\\\".\");\n      }\n      candidatePrefix = \"xmlns\";\n    }\n    if (candidatePrefix !== null) {\n      qualifiedName = candidatePrefix + \":\" + node.localName;\n      if (localDefaultNamespace !== null && localDefaultNamespace !== NAMESPACES.XML) {\n        inheritedNs = localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n      markup += qualifiedName;\n    } else if (prefix !== null) {\n      if (prefix in localPrefixesMap) {\n        prefix = attributeUtils.generatePrefix(map, ns, refs.prefixIndex++);\n      }\n      if (map[ns]) {\n        map[ns].push(prefix);\n      } else {\n        map[ns] = [prefix];\n      }\n      qualifiedName = prefix + \":\" + node.localName;\n      markup += `${qualifiedName} xmlns:${prefix}=\"${attributeUtils.serializeAttributeValue(ns, requireWellFormed)}\"`;\n      if (localDefaultNamespace !== null) {\n        inheritedNs = localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n    } else if (localDefaultNamespace === null || localDefaultNamespace !== ns) {\n      ignoreNamespaceDefinitionAttr = true;\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += `${qualifiedName} xmlns=\"${attributeUtils.serializeAttributeValue(ns, requireWellFormed)}\"`;\n    } else {\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += qualifiedName;\n    }\n  }\n  markup += attributeUtils.serializeAttributes(node, map, localPrefixesMap, ignoreNamespaceDefinitionAttr, requireWellFormed, refs);\n  if (ns === NAMESPACES.HTML && node.childNodes.length === 0 && VOID_ELEMENTS.has(node.localName)) {\n    markup += \" /\";\n    skipEndTag = true;\n  } else if (ns !== NAMESPACES.HTML && node.childNodes.length === 0) {\n    markup += \"/\";\n    skipEndTag = true;\n  }\n  markup += \">\";\n  if (skipEndTag) {\n    return markup;\n  }\n  if (ns === NAMESPACES.HTML && node.localName === \"template\") {\n    markup += xmlSerialization(node.content, inheritedNs, map, requireWellFormed, refs);\n  } else {\n    for (const child of node.childNodes) {\n      markup += xmlSerialization(child, inheritedNs, map, requireWellFormed, refs);\n    }\n  }\n  markup += `</${qualifiedName}>`;\n  return markup;\n}\nfunction serializeCDATASection(node) {\n  return \"<![CDATA[\" + node.data + \"]]>\";\n}\n\n/**\n * @param {{prefixIndex: number}} refs\n */\nfunction xmlSerialization(node, namespace, prefixMap, requireWellFormed, refs) {\n  switch (node.nodeType) {\n    case NODE_TYPES.ELEMENT_NODE:\n      return serializeElement(node, namespace, prefixMap, requireWellFormed, refs);\n    case NODE_TYPES.DOCUMENT_NODE:\n      return serializeDocument(node, namespace, prefixMap, requireWellFormed, refs);\n    case NODE_TYPES.COMMENT_NODE:\n      return serializeComment(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.TEXT_NODE:\n      return serializeText(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed, refs);\n    case NODE_TYPES.DOCUMENT_TYPE_NODE:\n      return serializeDocumentType(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.PROCESSING_INSTRUCTION_NODE:\n      return serializeProcessingInstruction(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.ATTRIBUTE_NODE:\n      return \"\";\n    case NODE_TYPES.CDATA_SECTION_NODE:\n      return serializeCDATASection(node);\n    default:\n      throw new TypeError(\"Failed to serialize XML: only Nodes can be serialized.\");\n  }\n}\nmodule.exports = (root, {\n  requireWellFormed = false\n} = {}) => {\n  const namespacePrefixMap = Object.create(null);\n  namespacePrefixMap[\"http://www.w3.org/XML/1998/namespace\"] = [\"xml\"];\n  return xmlSerialization(root, null, namespacePrefixMap, requireWellFormed, {\n    prefixIndex: 1\n  });\n};","map":{"version":3,"names":["xnv","require","attributeUtils","NAMESPACES","VOID_ELEMENTS","NODE_TYPES","XML_CHAR","PUBID_CHAR","asciiCaseInsensitiveMatch","a","b","length","i","charCodeAt","recordNamespaceInformation","element","map","prefixMap","defaultNamespaceAttrValue","attributes","attr","namespaceURI","XMLNS","prefix","value","namespaceDefinition","XML","includes","localName","push","serializeDocumentType","node","namespace","requireWellFormed","test","publicId","Error","systemId","markup","name","serializeProcessingInstruction","target","data","serializeDocument","refs","documentElement","serializedDocument","child","childNodes","xmlSerialization","serializeDocumentFragment","serializeText","replace","serializeComment","endsWith","serializeElement","qualifiedName","skipEndTag","ignoreNamespaceDefinitionAttr","Object","assign","localPrefixesMap","create","localDefaultNamespace","inheritedNs","ns","candidatePrefix","preferredPrefixString","generatePrefix","prefixIndex","serializeAttributeValue","serializeAttributes","HTML","has","content","serializeCDATASection","nodeType","ELEMENT_NODE","DOCUMENT_NODE","COMMENT_NODE","TEXT_NODE","DOCUMENT_FRAGMENT_NODE","DOCUMENT_TYPE_NODE","PROCESSING_INSTRUCTION_NODE","ATTRIBUTE_NODE","CDATA_SECTION_NODE","TypeError","module","exports","root","namespacePrefixMap"],"sources":["D:/benki/Programming/GitHub/homelab-dashboard/client/homelab-dashboard/node_modules/w3c-xmlserializer/lib/serialize.js"],"sourcesContent":["\"use strict\";\n\nconst xnv = require(\"xml-name-validator\");\n\nconst attributeUtils = require(\"./attributes\");\nconst { NAMESPACES, VOID_ELEMENTS, NODE_TYPES } = require(\"./constants\");\n\nconst XML_CHAR = /^(\\x09|\\x0A|\\x0D|[\\x20-\\uD7FF]|[\\uE000-\\uFFFD]|(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]))*$/;\nconst PUBID_CHAR = /^(\\x20|\\x0D|\\x0A|[a-zA-Z0-9]|[-'()+,./:=?;!*#@$_%])*$/;\n\nfunction asciiCaseInsensitiveMatch(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; ++i) {\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction recordNamespaceInformation(element, map, prefixMap) {\n  let defaultNamespaceAttrValue = null;\n  for (let i = 0; i < element.attributes.length; ++i) {\n    const attr = element.attributes[i];\n    if (attr.namespaceURI === NAMESPACES.XMLNS) {\n      if (attr.prefix === null) {\n        defaultNamespaceAttrValue = attr.value;\n        continue;\n      }\n      let namespaceDefinition = attr.value;\n      if (namespaceDefinition === NAMESPACES.XML) {\n        continue;\n      }\n      // This is exactly the other way than the spec says, but that's intended.\n      // All the maps coalesce null to the empty string (explained in the\n      // spec), so instead of doing that every time, just do it once here.\n      if (namespaceDefinition === null) {\n        namespaceDefinition = \"\";\n      }\n\n      if (\n        namespaceDefinition in map &&\n        map[namespaceDefinition].includes(attr.localName)\n      ) {\n        continue;\n      }\n      if (!(namespaceDefinition in map)) {\n        map[namespaceDefinition] = [];\n      }\n      map[namespaceDefinition].push(attr.localName);\n      prefixMap[attr.localName] = namespaceDefinition;\n    }\n  }\n  return defaultNamespaceAttrValue;\n}\n\nfunction serializeDocumentType(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !PUBID_CHAR.test(node.publicId)) {\n    throw new Error(\"Failed to serialize XML: document type node publicId is not well-formed.\");\n  }\n\n  if (\n    requireWellFormed &&\n    (!XML_CHAR.test(node.systemId) ||\n      (node.systemId.includes('\"') && node.systemId.includes(\"'\")))\n  ) {\n    throw new Error(\"Failed to serialize XML: document type node systemId is not well-formed.\");\n  }\n\n  let markup = `<!DOCTYPE ${node.name}`;\n  if (node.publicId !== \"\") {\n    markup += ` PUBLIC \"${node.publicId}\"`;\n  } else if (node.systemId !== \"\") {\n    markup += \" SYSTEM\";\n  }\n  if (node.systemId !== \"\") {\n    markup += ` \"${node.systemId}\"`;\n  }\n  return markup + \">\";\n}\n\nfunction serializeProcessingInstruction(\n  node,\n  namespace,\n  prefixMap,\n  requireWellFormed\n) {\n  if (\n    requireWellFormed &&\n    (node.target.includes(\":\") || asciiCaseInsensitiveMatch(node.target, \"xml\"))\n  ) {\n    throw new Error(\"Failed to serialize XML: processing instruction node target is not well-formed.\");\n  }\n  if (\n    requireWellFormed &&\n    (!XML_CHAR.test(node.data) || node.data.includes(\"?>\"))\n  ) {\n    throw new Error(\"Failed to serialize XML: processing instruction node data is not well-formed.\");\n  }\n  return `<?${node.target} ${node.data}?>`;\n}\n\nfunction serializeDocument(\n  node,\n  namespace,\n  prefixMap,\n  requireWellFormed,\n  refs\n) {\n  if (requireWellFormed && node.documentElement === null) {\n    throw new Error(\"Failed to serialize XML: document does not have a document element.\");\n  }\n  let serializedDocument = \"\";\n  for (const child of node.childNodes) {\n    serializedDocument += xmlSerialization(\n      child,\n      namespace,\n      prefixMap,\n      requireWellFormed,\n      refs\n    );\n  }\n  return serializedDocument;\n}\n\nfunction serializeDocumentFragment(\n  node,\n  namespace,\n  prefixMap,\n  requireWellFormed,\n  refs\n) {\n  let markup = \"\";\n  for (const child of node.childNodes) {\n    markup += xmlSerialization(\n      child,\n      namespace,\n      prefixMap,\n      requireWellFormed,\n      refs\n    );\n  }\n  return markup;\n}\n\nfunction serializeText(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: text node data is not well-formed.\");\n  }\n\n  return node.data\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\");\n}\n\nfunction serializeComment(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: comment node data is not well-formed.\");\n  }\n\n  if (\n    requireWellFormed &&\n    (node.data.includes(\"--\") || node.data.endsWith(\"-\"))\n  ) {\n    throw new Error(\"Failed to serialize XML: found hyphens in illegal places in comment node data.\");\n  }\n  return `<!--${node.data}-->`;\n}\n\nfunction serializeElement(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (\n    requireWellFormed &&\n    (node.localName.includes(\":\") || !xnv.name(node.localName))\n  ) {\n    throw new Error(\"Failed to serialize XML: element node localName is not a valid XML name.\");\n  }\n  let markup = \"<\";\n  let qualifiedName = \"\";\n  let skipEndTag = false;\n  let ignoreNamespaceDefinitionAttr = false;\n  const map = Object.assign({}, prefixMap);\n  const localPrefixesMap = Object.create(null);\n  const localDefaultNamespace = recordNamespaceInformation(\n    node,\n    map,\n    localPrefixesMap\n  );\n  let inheritedNs = namespace;\n  const ns = node.namespaceURI;\n  if (inheritedNs === ns) {\n    if (localDefaultNamespace !== null) {\n      ignoreNamespaceDefinitionAttr = true;\n    }\n    if (ns === NAMESPACES.XML) {\n      qualifiedName = \"xml:\" + node.localName;\n    } else {\n      qualifiedName = node.localName;\n    }\n    markup += qualifiedName;\n  } else {\n    let { prefix } = node;\n    let candidatePrefix = attributeUtils.preferredPrefixString(map, ns, prefix);\n    if (prefix === \"xmlns\") {\n      if (requireWellFormed) {\n        throw new Error(\"Failed to serialize XML: element nodes can't have a prefix of \\\"xmlns\\\".\");\n      }\n      candidatePrefix = \"xmlns\";\n    }\n    if (candidatePrefix !== null) {\n      qualifiedName = candidatePrefix + \":\" + node.localName;\n      if (\n        localDefaultNamespace !== null &&\n        localDefaultNamespace !== NAMESPACES.XML\n      ) {\n        inheritedNs =\n          localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n      markup += qualifiedName;\n    } else if (prefix !== null) {\n      if (prefix in localPrefixesMap) {\n        prefix = attributeUtils.generatePrefix(map, ns, refs.prefixIndex++);\n      }\n      if (map[ns]) {\n        map[ns].push(prefix);\n      } else {\n        map[ns] = [prefix];\n      }\n      qualifiedName = prefix + \":\" + node.localName;\n      markup += `${qualifiedName} xmlns:${prefix}=\"${attributeUtils.serializeAttributeValue(\n        ns,\n        requireWellFormed\n      )}\"`;\n      if (localDefaultNamespace !== null) {\n        inheritedNs =\n          localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n    } else if (localDefaultNamespace === null || localDefaultNamespace !== ns) {\n      ignoreNamespaceDefinitionAttr = true;\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += `${qualifiedName} xmlns=\"${attributeUtils.serializeAttributeValue(\n        ns,\n        requireWellFormed\n      )}\"`;\n    } else {\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += qualifiedName;\n    }\n  }\n\n  markup += attributeUtils.serializeAttributes(\n    node,\n    map,\n    localPrefixesMap,\n    ignoreNamespaceDefinitionAttr,\n    requireWellFormed,\n    refs\n  );\n\n  if (\n    ns === NAMESPACES.HTML &&\n    node.childNodes.length === 0 &&\n    VOID_ELEMENTS.has(node.localName)\n  ) {\n    markup += \" /\";\n    skipEndTag = true;\n  } else if (ns !== NAMESPACES.HTML && node.childNodes.length === 0) {\n    markup += \"/\";\n    skipEndTag = true;\n  }\n  markup += \">\";\n  if (skipEndTag) {\n    return markup;\n  }\n\n  if (ns === NAMESPACES.HTML && node.localName === \"template\") {\n    markup += xmlSerialization(\n      node.content,\n      inheritedNs,\n      map,\n      requireWellFormed,\n      refs\n    );\n  } else {\n    for (const child of node.childNodes) {\n      markup += xmlSerialization(\n        child,\n        inheritedNs,\n        map,\n        requireWellFormed,\n        refs\n      );\n    }\n  }\n  markup += `</${qualifiedName}>`;\n  return markup;\n}\n\nfunction serializeCDATASection(node) {\n  return \"<![CDATA[\" + node.data + \"]]>\";\n}\n\n/**\n * @param {{prefixIndex: number}} refs\n */\nfunction xmlSerialization(node, namespace, prefixMap, requireWellFormed, refs) {\n  switch (node.nodeType) {\n    case NODE_TYPES.ELEMENT_NODE:\n      return serializeElement(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed,\n        refs\n      );\n    case NODE_TYPES.DOCUMENT_NODE:\n      return serializeDocument(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed,\n        refs\n      );\n    case NODE_TYPES.COMMENT_NODE:\n      return serializeComment(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.TEXT_NODE:\n      return serializeText(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragment(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed,\n        refs\n      );\n    case NODE_TYPES.DOCUMENT_TYPE_NODE:\n      return serializeDocumentType(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed\n      );\n    case NODE_TYPES.PROCESSING_INSTRUCTION_NODE:\n      return serializeProcessingInstruction(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed\n      );\n    case NODE_TYPES.ATTRIBUTE_NODE:\n      return \"\";\n    case NODE_TYPES.CDATA_SECTION_NODE:\n      return serializeCDATASection(node);\n    default:\n      throw new TypeError(\"Failed to serialize XML: only Nodes can be serialized.\");\n  }\n}\n\nmodule.exports = (root, { requireWellFormed = false } = {}) => {\n  const namespacePrefixMap = Object.create(null);\n  namespacePrefixMap[\"http://www.w3.org/XML/1998/namespace\"] = [\"xml\"];\n  return xmlSerialization(root, null, namespacePrefixMap, requireWellFormed, {\n    prefixIndex: 1\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}