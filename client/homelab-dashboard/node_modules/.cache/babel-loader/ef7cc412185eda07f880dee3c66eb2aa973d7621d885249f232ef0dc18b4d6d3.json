{"ast":null,"code":"\"use strict\";\n\nconst whatwgURL = require(\"whatwg-url\");\nconst HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\nconst PopStateEvent = require(\"../generated/PopStateEvent.js\");\nconst notImplemented = require(\"../../browser/not-implemented.js\");\nconst idlUtils = require(\"../generated/utils.js\");\nconst {\n  fireAnEvent\n} = require(\"../helpers/events\");\n\n// https://html.spec.whatwg.org/#session-history\nclass SessionHistory {\n  constructor(initialEntry, window) {\n    this._window = window;\n    this._windowImpl = idlUtils.implForWrapper(window);\n    this._historyTraversalQueue = new Set();\n    this._entries = [initialEntry];\n    this._currentIndex = 0;\n  }\n  _queueHistoryTraversalTask(fn) {\n    const timeoutId = this._window.setTimeout(() => {\n      this._historyTraversalQueue.delete(timeoutId);\n      fn();\n    }, 0);\n    this._historyTraversalQueue.add(timeoutId);\n  }\n  clearHistoryTraversalTasks() {\n    for (const timeoutId of this._historyTraversalQueue) {\n      this._window.clearTimeout(timeoutId);\n    }\n    this._historyTraversalQueue.clear();\n  }\n  get length() {\n    return this._entries.length;\n  }\n  get currentEntry() {\n    return this._entries[this._currentIndex];\n  }\n\n  // https://html.spec.whatwg.org/#dom-history-pushstate\n  removeAllEntriesAfterCurrentEntry() {\n    this._entries.splice(this._currentIndex + 1, Infinity);\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta\n  traverseByDelta(delta) {\n    this._queueHistoryTraversalTask(() => {\n      const newIndex = this._currentIndex + delta;\n      if (newIndex < 0 || newIndex >= this.length) {\n        return;\n      }\n      const specifiedEntry = this._entries[newIndex];\n\n      // Not implemented: unload a document guard\n\n      // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\n      // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\n      this._queueHistoryTraversalTask(() => {\n        // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,\n        // then cancel that attempt to navigate the browsing context.\n\n        // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this\n        // is because these navigations should already count as having \"matured\" because the document is not changing.\n\n        // this.clearHistoryTraversalTasks();\n\n        if (specifiedEntry.document !== this.currentEntry.document) {\n          // TODO: unload the active document with the recycle parameter set to false\n          notImplemented(\"Traversing history in a way that would change the window\", this._window);\n        }\n        this.traverseHistory(specifiedEntry);\n      });\n    });\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history\n  traverseHistory(specifiedEntry, flags = {}) {\n    if (!specifiedEntry.document) {\n      // If entry no longer holds a Document object, then navigate the browsing context to entry's URL\n      // to perform an entry update of entry, and abort these steps\n      notImplemented(\"Traversing the history to an entry that no longer holds a Document object\", this._window);\n    }\n    // Not spec compliant, just minimal. Lots of missing steps.\n\n    const nonBlockingEvents = Boolean(flags.nonBlockingEvents);\n    const document = idlUtils.implForWrapper(this._window._document);\n    const {\n      currentEntry\n    } = this;\n\n    // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title\n    // to the value returned by the document.title IDL attribute.\n    if (currentEntry.title === undefined) {\n      currentEntry.title = document.title;\n    }\n    if (specifiedEntry.document !== currentEntry.document) {\n      // If entry has a different Document object than the current entry, then...\n      notImplemented(\"Traversing the history to an entry with a different Document\", this._window);\n    }\n    document._URL = specifiedEntry.url;\n    const hashChanged = specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;\n    let oldURL, newURL;\n    if (hashChanged) {\n      oldURL = currentEntry.url;\n      newURL = specifiedEntry.url;\n    }\n    if (flags.replacement) {\n      // If the traversal was initiated with replacement enabled, remove the entry immediately before the\n      // specified entry in the session history.\n      this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);\n    }\n    this.updateCurrentEntry(specifiedEntry);\n    const state = specifiedEntry.stateObject; // TODO structured clone\n\n    // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n    // but the spec gives them to \"History\" and \"Document\" respecively.\n    document._history._state = state;\n    const stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;\n    specifiedEntry.document._latestEntry = specifiedEntry;\n    const fireEvents = () => this._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);\n    if (nonBlockingEvents) {\n      this._window.setTimeout(fireEvents, 0);\n    } else {\n      fireEvents();\n    }\n  }\n  _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {\n    if (stateChanged) {\n      fireAnEvent(\"popstate\", this._windowImpl, PopStateEvent, {\n        state\n      });\n    }\n    if (hashChanged) {\n      fireAnEvent(\"hashchange\", this._windowImpl, HashChangeEvent, {\n        oldURL: whatwgURL.serializeURL(oldURL),\n        newURL: whatwgURL.serializeURL(newURL)\n      });\n    }\n  }\n  addEntryAfterCurrentEntry(entry) {\n    this._entries.splice(this._currentIndex + 1, 0, entry);\n  }\n  updateCurrentEntry(entry) {\n    this._currentIndex = this._entries.indexOf(entry);\n  }\n}\nmodule.exports = SessionHistory;","map":{"version":3,"names":["whatwgURL","require","HashChangeEvent","PopStateEvent","notImplemented","idlUtils","fireAnEvent","SessionHistory","constructor","initialEntry","window","_window","_windowImpl","implForWrapper","_historyTraversalQueue","Set","_entries","_currentIndex","_queueHistoryTraversalTask","fn","timeoutId","setTimeout","delete","add","clearHistoryTraversalTasks","clearTimeout","clear","length","currentEntry","removeAllEntriesAfterCurrentEntry","splice","Infinity","traverseByDelta","delta","newIndex","specifiedEntry","document","traverseHistory","flags","nonBlockingEvents","Boolean","_document","title","undefined","_URL","url","hashChanged","fragment","oldURL","newURL","replacement","indexOf","updateCurrentEntry","state","stateObject","_history","_state","stateChanged","_latestEntry","fireEvents","_fireEvents","serializeURL","addEntryAfterCurrentEntry","entry","module","exports"],"sources":["D:/benki/Programming/GitHub/homelab-dashboard/client/homelab-dashboard/node_modules/jsdom/lib/jsdom/living/window/SessionHistory.js"],"sourcesContent":["\"use strict\";\nconst whatwgURL = require(\"whatwg-url\");\nconst HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\nconst PopStateEvent = require(\"../generated/PopStateEvent.js\");\nconst notImplemented = require(\"../../browser/not-implemented.js\");\nconst idlUtils = require(\"../generated/utils.js\");\nconst { fireAnEvent } = require(\"../helpers/events\");\n\n// https://html.spec.whatwg.org/#session-history\nclass SessionHistory {\n  constructor(initialEntry, window) {\n    this._window = window;\n    this._windowImpl = idlUtils.implForWrapper(window);\n    this._historyTraversalQueue = new Set();\n    this._entries = [initialEntry];\n    this._currentIndex = 0;\n  }\n\n  _queueHistoryTraversalTask(fn) {\n    const timeoutId = this._window.setTimeout(() => {\n      this._historyTraversalQueue.delete(timeoutId);\n      fn();\n    }, 0);\n\n    this._historyTraversalQueue.add(timeoutId);\n  }\n\n  clearHistoryTraversalTasks() {\n    for (const timeoutId of this._historyTraversalQueue) {\n      this._window.clearTimeout(timeoutId);\n    }\n    this._historyTraversalQueue.clear();\n  }\n\n  get length() {\n    return this._entries.length;\n  }\n\n  get currentEntry() {\n    return this._entries[this._currentIndex];\n  }\n\n  // https://html.spec.whatwg.org/#dom-history-pushstate\n  removeAllEntriesAfterCurrentEntry() {\n    this._entries.splice(this._currentIndex + 1, Infinity);\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta\n  traverseByDelta(delta) {\n    this._queueHistoryTraversalTask(() => {\n      const newIndex = this._currentIndex + delta;\n      if (newIndex < 0 || newIndex >= this.length) {\n        return;\n      }\n\n      const specifiedEntry = this._entries[newIndex];\n\n      // Not implemented: unload a document guard\n\n      // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\n      // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\n      this._queueHistoryTraversalTask(() => {\n        // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,\n        // then cancel that attempt to navigate the browsing context.\n\n        // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this\n        // is because these navigations should already count as having \"matured\" because the document is not changing.\n\n        // this.clearHistoryTraversalTasks();\n\n        if (specifiedEntry.document !== this.currentEntry.document) {\n          // TODO: unload the active document with the recycle parameter set to false\n          notImplemented(\"Traversing history in a way that would change the window\", this._window);\n        }\n        this.traverseHistory(specifiedEntry);\n      });\n    });\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history\n  traverseHistory(specifiedEntry, flags = {}) {\n    if (!specifiedEntry.document) {\n      // If entry no longer holds a Document object, then navigate the browsing context to entry's URL\n      // to perform an entry update of entry, and abort these steps\n      notImplemented(\"Traversing the history to an entry that no longer holds a Document object\", this._window);\n    }\n    // Not spec compliant, just minimal. Lots of missing steps.\n\n    const nonBlockingEvents = Boolean(flags.nonBlockingEvents);\n\n    const document = idlUtils.implForWrapper(this._window._document);\n\n    const { currentEntry } = this;\n\n    // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title\n    // to the value returned by the document.title IDL attribute.\n    if (currentEntry.title === undefined) {\n      currentEntry.title = document.title;\n    }\n\n\n    if (specifiedEntry.document !== currentEntry.document) {\n      // If entry has a different Document object than the current entry, then...\n      notImplemented(\"Traversing the history to an entry with a different Document\", this._window);\n    }\n\n    document._URL = specifiedEntry.url;\n\n    const hashChanged =\n      specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;\n    let oldURL, newURL;\n    if (hashChanged) {\n      oldURL = currentEntry.url;\n      newURL = specifiedEntry.url;\n    }\n\n    if (flags.replacement) {\n      // If the traversal was initiated with replacement enabled, remove the entry immediately before the\n      // specified entry in the session history.\n      this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);\n    }\n\n    this.updateCurrentEntry(specifiedEntry);\n\n    const state = specifiedEntry.stateObject; // TODO structured clone\n\n    // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n    // but the spec gives them to \"History\" and \"Document\" respecively.\n    document._history._state = state;\n    const stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;\n    specifiedEntry.document._latestEntry = specifiedEntry;\n\n    const fireEvents = () => this._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);\n\n    if (nonBlockingEvents) {\n      this._window.setTimeout(fireEvents, 0);\n    } else {\n      fireEvents();\n    }\n  }\n\n  _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {\n    if (stateChanged) {\n      fireAnEvent(\"popstate\", this._windowImpl, PopStateEvent, { state });\n    }\n\n    if (hashChanged) {\n      fireAnEvent(\"hashchange\", this._windowImpl, HashChangeEvent, {\n        oldURL: whatwgURL.serializeURL(oldURL),\n        newURL: whatwgURL.serializeURL(newURL)\n      });\n    }\n  }\n\n  addEntryAfterCurrentEntry(entry) {\n    this._entries.splice(this._currentIndex + 1, 0, entry);\n  }\n\n  updateCurrentEntry(entry) {\n    this._currentIndex = this._entries.indexOf(entry);\n  }\n}\nmodule.exports = SessionHistory;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}