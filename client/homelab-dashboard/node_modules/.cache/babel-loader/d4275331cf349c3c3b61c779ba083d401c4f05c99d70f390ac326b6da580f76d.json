{"ast":null,"code":"\"use strict\";\n\nconst fs = require(\"fs\");\nconst {\n  EventEmitter\n} = require(\"events\");\nconst {\n  URL\n} = require(\"whatwg-url\");\nconst parseDataURL = require(\"data-urls\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\nconst agentFactory = require(\"../helpers/agent-factory\");\nconst Request = require(\"../helpers/http-request\");\nconst FormData = require(\"form-data\");\nconst {\n  fireAnEvent\n} = require(\"../helpers/events\");\nconst headerListSeparatorRegexp = /,[ \\t]*/;\nconst simpleMethods = new Set([\"GET\", \"HEAD\", \"POST\"]);\nconst simpleHeaders = new Set([\"accept\", \"accept-language\", \"content-language\", \"content-type\"]);\nconst preflightHeaders = new Set([\"access-control-expose-headers\", \"access-control-allow-headers\", \"access-control-allow-credentials\", \"access-control-allow-origin\"]);\nconst READY_STATES = exports.READY_STATES = Object.freeze({\n  UNSENT: 0,\n  OPENED: 1,\n  HEADERS_RECEIVED: 2,\n  LOADING: 3,\n  DONE: 4\n});\nfunction getRequestHeader(requestHeaders, header) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      return requestHeaders[key];\n    }\n  }\n  return null;\n}\nfunction updateRequestHeader(requestHeaders, header, newValue) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      requestHeaders[key] = newValue;\n    }\n  }\n}\nfunction dispatchError(xhr) {\n  const errMessage = xhr.properties.error;\n  requestErrorSteps(xhr, \"error\", DOMException.create(xhr._globalObject, [errMessage, \"NetworkError\"]));\n  if (xhr._ownerDocument) {\n    const error = new Error(errMessage);\n    error.type = \"XMLHttpRequest\"; // TODO this should become \"resource loading\" when XHR goes through resource loader\n\n    xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n  }\n}\nfunction validCORSHeaders(xhr, response, flag, properties, origin) {\n  const acaoStr = response.headers[\"access-control-allow-origin\"];\n  const acao = acaoStr ? acaoStr.trim() : null;\n  if (acao !== \"*\" && acao !== origin) {\n    properties.error = \"Cross origin \" + origin + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  const acacStr = response.headers[\"access-control-allow-credentials\"];\n  const acac = acacStr ? acacStr.trim() : null;\n  if (flag.withCredentials && acac !== \"true\") {\n    properties.error = \"Credentials forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  return true;\n}\nfunction validCORSPreflightHeaders(xhr, response, flag, properties) {\n  if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n    return false;\n  }\n  const acahStr = response.headers[\"access-control-allow-headers\"];\n  const acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n  const forbiddenHeaders = acah.has(\"*\") ? [] : Object.keys(flag.requestHeaders).filter(header => {\n    const lcHeader = header.toLowerCase();\n    return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n  });\n  if (forbiddenHeaders.length > 0) {\n    properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  return true;\n}\nfunction requestErrorSteps(xhr, event, exception) {\n  const {\n    flag,\n    properties,\n    upload\n  } = xhr;\n  xhr.readyState = READY_STATES.DONE;\n  properties.send = false;\n  setResponseToNetworkError(xhr);\n  if (flag.synchronous) {\n    throw exception;\n  }\n  fireAnEvent(\"readystatechange\", xhr);\n  if (!properties.uploadComplete) {\n    properties.uploadComplete = true;\n    if (properties.uploadListener) {\n      fireAnEvent(event, upload, ProgressEvent, {\n        loaded: 0,\n        total: 0,\n        lengthComputable: false\n      });\n      fireAnEvent(\"loadend\", upload, ProgressEvent, {\n        loaded: 0,\n        total: 0,\n        lengthComputable: false\n      });\n    }\n  }\n  fireAnEvent(event, xhr, ProgressEvent, {\n    loaded: 0,\n    total: 0,\n    lengthComputable: false\n  });\n  fireAnEvent(\"loadend\", xhr, ProgressEvent, {\n    loaded: 0,\n    total: 0,\n    lengthComputable: false\n  });\n}\nfunction setResponseToNetworkError(xhr) {\n  const {\n    properties\n  } = xhr;\n  properties.responseBuffer = properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n  properties.responseHeaders = {};\n  xhr.status = 0;\n  xhr.statusText = \"\";\n}\n\n// return a \"request\" client object or an event emitter matching the same behaviour for unsupported protocols\n// the callback should be called with a \"request\" response object or an event emitter matching the same behaviour too\nfunction createClient(xhr) {\n  const {\n    flag,\n    properties\n  } = xhr;\n  const urlObj = new URL(flag.uri);\n  const uri = urlObj.href;\n  const ucMethod = flag.method.toUpperCase();\n  const {\n    requestManager\n  } = flag;\n  if (urlObj.protocol === \"file:\") {\n    const response = new EventEmitter();\n    response.statusCode = 200;\n    response.rawHeaders = [];\n    response.headers = {};\n    const filePath = urlObj.pathname.replace(/^file:\\/\\//, \"\").replace(/^\\/([a-z]):\\//i, \"$1:/\").replace(/%20/g, \" \");\n    const client = new EventEmitter();\n    const readableStream = fs.createReadStream(filePath, {\n      encoding: null\n    });\n    readableStream.on(\"data\", chunk => {\n      response.emit(\"data\", chunk);\n      client.emit(\"data\", chunk);\n    });\n    readableStream.on(\"end\", () => {\n      response.emit(\"end\");\n      client.emit(\"end\");\n    });\n    readableStream.on(\"error\", err => {\n      client.emit(\"error\", err);\n    });\n    client.abort = function () {\n      readableStream.destroy();\n      client.emit(\"abort\");\n    };\n    if (requestManager) {\n      const req = {\n        abort() {\n          properties.abortError = true;\n          xhr.abort();\n        }\n      };\n      requestManager.add(req);\n      const rmReq = requestManager.remove.bind(requestManager, req);\n      client.on(\"abort\", rmReq);\n      client.on(\"error\", rmReq);\n      client.on(\"end\", rmReq);\n    }\n    process.nextTick(() => client.emit(\"response\", response, urlObj.href));\n    return client;\n  }\n  if (urlObj.protocol === \"data:\") {\n    const response = new EventEmitter();\n    const client = new EventEmitter();\n    let buffer;\n    try {\n      const parsed = parseDataURL(uri);\n      const contentType = parsed.mimeType.toString();\n      buffer = parsed.body;\n      response.statusCode = 200;\n      response.rawHeaders = [\"Content-Type\", contentType];\n      response.headers = {\n        \"content-type\": contentType\n      };\n    } catch (err) {\n      process.nextTick(() => client.emit(\"error\", err));\n      return client;\n    }\n    client.abort = () => {\n      // do nothing\n    };\n    process.nextTick(() => {\n      client.emit(\"response\", response, urlObj.href);\n      process.nextTick(() => {\n        response.emit(\"data\", buffer);\n        client.emit(\"data\", buffer);\n        response.emit(\"end\");\n        client.emit(\"end\");\n      });\n    });\n    return client;\n  }\n  const agents = agentFactory(flag.proxy, flag.strictSSL);\n  const requestHeaders = {};\n  for (const header in flag.requestHeaders) {\n    requestHeaders[header] = flag.requestHeaders[header];\n  }\n  if (getRequestHeader(flag.requestHeaders, \"referer\") === null) {\n    requestHeaders.Referer = flag.referrer;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"user-agent\") === null) {\n    requestHeaders[\"User-Agent\"] = flag.userAgent;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept-language\") === null) {\n    requestHeaders[\"Accept-Language\"] = \"en\";\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept\") === null) {\n    requestHeaders.Accept = \"*/*\";\n  }\n  const crossOrigin = flag.origin !== urlObj.origin;\n  if (crossOrigin) {\n    requestHeaders.Origin = flag.origin;\n  }\n  const options = {\n    rejectUnauthorized: flag.strictSSL,\n    agents,\n    followRedirects: true\n  };\n  if (flag.auth) {\n    options.user = flag.auth.user || \"\";\n    options.pass = flag.auth.pass || \"\";\n  }\n  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {\n    options.cookieJar = flag.cookieJar;\n  }\n  const {\n    body\n  } = flag;\n  const hasBody = body !== undefined && body !== null && body !== \"\" && !(ucMethod === \"HEAD\" || ucMethod === \"GET\");\n  if (hasBody && getRequestHeader(flag.requestHeaders, \"content-type\") === null) {\n    requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n  }\n  function doRequest() {\n    try {\n      let requestBody = body;\n      let len = 0;\n      if (hasBody) {\n        if (flag.formData) {\n          // TODO: implement https://html.spec.whatwg.org/#multipart-form-data\n          // directly instead of using an external library\n          requestBody = new FormData();\n          for (const entry of body) {\n            requestBody.append(entry.name, entry.value, entry.options);\n          }\n          len = requestBody.getLengthSync();\n          requestHeaders[\"Content-Type\"] = `multipart/form-data; boundary=${requestBody.getBoundary()}`;\n        } else {\n          if (typeof body === \"string\") {\n            len = Buffer.byteLength(body);\n          } else {\n            len = body.length;\n          }\n          requestBody = Buffer.isBuffer(requestBody) ? requestBody : Buffer.from(requestBody);\n        }\n        requestHeaders[\"Content-Length\"] = len;\n      }\n      requestHeaders[\"Accept-Encoding\"] = \"gzip, deflate\";\n      const requestClient = new Request(uri, options, {\n        method: flag.method,\n        headers: requestHeaders\n      });\n      if (hasBody) {\n        if (flag.formData) {\n          requestBody.on(\"error\", err => {\n            requestClient.emit(\"error\", err);\n            requestClient.abort();\n          });\n          requestClient.pipeRequest(requestBody);\n        } else {\n          requestClient.write(requestBody);\n        }\n      }\n      return requestClient;\n    } catch (e) {\n      const eventEmitterclient = new EventEmitter();\n      process.nextTick(() => eventEmitterclient.emit(\"error\", e));\n      eventEmitterclient.end = () => {};\n      return eventEmitterclient;\n    }\n  }\n  let client;\n  const nonSimpleHeaders = Object.keys(flag.requestHeaders).filter(header => !simpleHeaders.has(header.toLowerCase()));\n  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0 || properties.uploadListener)) {\n    client = new EventEmitter();\n    const preflightRequestHeaders = {};\n    for (const header in requestHeaders) {\n      // the only existing request headers the cors spec allows on the preflight request are Origin and Referer\n      const lcHeader = header.toLowerCase();\n      if (lcHeader === \"origin\" || lcHeader === \"referer\") {\n        preflightRequestHeaders[header] = requestHeaders[header];\n      }\n    }\n    preflightRequestHeaders[\"Access-Control-Request-Method\"] = flag.method;\n    if (nonSimpleHeaders.length > 0) {\n      preflightRequestHeaders[\"Access-Control-Request-Headers\"] = nonSimpleHeaders.join(\", \");\n    }\n    preflightRequestHeaders[\"User-Agent\"] = flag.userAgent;\n    flag.preflight = true;\n    const rejectUnauthorized = flag.strictSSL;\n    const preflightClient = new Request(uri, {\n      agents,\n      followRedirects: false\n    }, {\n      method: \"OPTIONS\",\n      headers: preflightRequestHeaders,\n      rejectUnauthorized\n    });\n    preflightClient.on(\"response\", resp => {\n      // don't send the real request if the preflight request returned an error\n      if (resp.statusCode < 200 || resp.statusCode > 299) {\n        client.emit(\"error\", new Error(\"Response for preflight has invalid HTTP status code \" + resp.statusCode));\n        return;\n      }\n      // don't send the real request if we aren't allowed to use the headers\n      if (!validCORSPreflightHeaders(xhr, resp, flag, properties)) {\n        setResponseToNetworkError(xhr);\n        return;\n      }\n      // Set request gzip option right before headers are set\n      const realClient = doRequest();\n      realClient.on(\"response\", (...args) => client.emit(\"response\", ...args));\n      realClient.on(\"data\", chunk => client.emit(\"data\", chunk));\n      realClient.on(\"end\", () => client.emit(\"end\"));\n      realClient.on(\"abort\", () => client.emit(\"abort\"));\n      realClient.on(\"request\", req => {\n        client.headers = realClient.headers;\n        client.emit(\"request\", req);\n      });\n      realClient.on(\"redirect\", (...args) => {\n        client.emit(\"redirect\", ...args);\n      });\n      realClient.on(\"error\", err => {\n        client.emit(\"error\", err);\n      });\n      client.abort = () => {\n        realClient.abort();\n      };\n      setImmediate(() => realClient.end());\n    });\n    preflightClient.on(\"error\", err => {\n      client.emit(\"error\", err);\n    });\n    client.abort = () => {\n      preflightClient.abort();\n    };\n    setImmediate(() => preflightClient.end());\n  } else {\n    client = doRequest();\n    setImmediate(() => client.end());\n  }\n  if (requestManager) {\n    const req = {\n      abort() {\n        properties.abortError = true;\n        xhr.abort();\n      }\n    };\n    requestManager.add(req);\n    const rmReq = requestManager.remove.bind(requestManager, req);\n    client.on(\"abort\", rmReq);\n    client.on(\"error\", rmReq);\n    client.on(\"end\", rmReq);\n  }\n  return client;\n}\nexports.headerListSeparatorRegexp = headerListSeparatorRegexp;\nexports.simpleHeaders = simpleHeaders;\nexports.preflightHeaders = preflightHeaders;\nexports.getRequestHeader = getRequestHeader;\nexports.updateRequestHeader = updateRequestHeader;\nexports.dispatchError = dispatchError;\nexports.validCORSHeaders = validCORSHeaders;\nexports.requestErrorSteps = requestErrorSteps;\nexports.setResponseToNetworkError = setResponseToNetworkError;\nexports.createClient = createClient;","map":{"version":3,"names":["fs","require","EventEmitter","URL","parseDataURL","DOMException","ProgressEvent","agentFactory","Request","FormData","fireAnEvent","headerListSeparatorRegexp","simpleMethods","Set","simpleHeaders","preflightHeaders","READY_STATES","exports","Object","freeze","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","getRequestHeader","requestHeaders","header","lcHeader","toLowerCase","keys","n","length","key","updateRequestHeader","newValue","dispatchError","xhr","errMessage","properties","error","requestErrorSteps","create","_globalObject","_ownerDocument","Error","type","_defaultView","_virtualConsole","emit","validCORSHeaders","response","flag","origin","acaoStr","headers","acao","trim","acacStr","acac","withCredentials","validCORSPreflightHeaders","acahStr","acah","split","forbiddenHeaders","has","filter","event","exception","upload","readyState","send","setResponseToNetworkError","synchronous","uploadComplete","uploadListener","loaded","total","lengthComputable","responseBuffer","responseCache","responseTextCache","responseXMLCache","responseHeaders","status","statusText","createClient","urlObj","uri","href","ucMethod","method","toUpperCase","requestManager","protocol","statusCode","rawHeaders","filePath","pathname","replace","client","readableStream","createReadStream","encoding","on","chunk","err","abort","destroy","req","abortError","add","rmReq","remove","bind","process","nextTick","buffer","parsed","contentType","mimeType","toString","body","agents","proxy","strictSSL","Referer","referrer","userAgent","Accept","crossOrigin","Origin","options","rejectUnauthorized","followRedirects","auth","user","pass","cookieJar","hasBody","undefined","doRequest","requestBody","len","formData","entry","append","name","value","getLengthSync","getBoundary","Buffer","byteLength","isBuffer","from","requestClient","pipeRequest","write","e","eventEmitterclient","end","nonSimpleHeaders","preflightRequestHeaders","join","preflight","preflightClient","resp","realClient","args","setImmediate"],"sources":["D:/benki/Programming/GitHub/homelab-dashboard/client/homelab-dashboard/node_modules/jsdom/lib/jsdom/living/xhr/xhr-utils.js"],"sourcesContent":["\"use strict\";\nconst fs = require(\"fs\");\nconst { EventEmitter } = require(\"events\");\nconst { URL } = require(\"whatwg-url\");\nconst parseDataURL = require(\"data-urls\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\n\nconst agentFactory = require(\"../helpers/agent-factory\");\nconst Request = require(\"../helpers/http-request\");\nconst FormData = require(\"form-data\");\nconst { fireAnEvent } = require(\"../helpers/events\");\n\nconst headerListSeparatorRegexp = /,[ \\t]*/;\nconst simpleMethods = new Set([\"GET\", \"HEAD\", \"POST\"]);\nconst simpleHeaders = new Set([\"accept\", \"accept-language\", \"content-language\", \"content-type\"]);\nconst preflightHeaders = new Set([\n  \"access-control-expose-headers\",\n  \"access-control-allow-headers\",\n  \"access-control-allow-credentials\",\n  \"access-control-allow-origin\"\n]);\n\nconst READY_STATES = exports.READY_STATES = Object.freeze({\n  UNSENT: 0,\n  OPENED: 1,\n  HEADERS_RECEIVED: 2,\n  LOADING: 3,\n  DONE: 4\n});\n\nfunction getRequestHeader(requestHeaders, header) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      return requestHeaders[key];\n    }\n  }\n  return null;\n}\n\nfunction updateRequestHeader(requestHeaders, header, newValue) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      requestHeaders[key] = newValue;\n    }\n  }\n}\n\nfunction dispatchError(xhr) {\n  const errMessage = xhr.properties.error;\n  requestErrorSteps(xhr, \"error\", DOMException.create(xhr._globalObject, [errMessage, \"NetworkError\"]));\n\n  if (xhr._ownerDocument) {\n    const error = new Error(errMessage);\n    error.type = \"XMLHttpRequest\"; // TODO this should become \"resource loading\" when XHR goes through resource loader\n\n    xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n  }\n}\n\nfunction validCORSHeaders(xhr, response, flag, properties, origin) {\n  const acaoStr = response.headers[\"access-control-allow-origin\"];\n  const acao = acaoStr ? acaoStr.trim() : null;\n  if (acao !== \"*\" && acao !== origin) {\n    properties.error = \"Cross origin \" + origin + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  const acacStr = response.headers[\"access-control-allow-credentials\"];\n  const acac = acacStr ? acacStr.trim() : null;\n  if (flag.withCredentials && acac !== \"true\") {\n    properties.error = \"Credentials forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  return true;\n}\n\nfunction validCORSPreflightHeaders(xhr, response, flag, properties) {\n  if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n    return false;\n  }\n  const acahStr = response.headers[\"access-control-allow-headers\"];\n  const acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n  const forbiddenHeaders = acah.has(\"*\") ?\n  [] :\n  Object.keys(flag.requestHeaders).filter(header => {\n    const lcHeader = header.toLowerCase();\n    return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n  });\n  if (forbiddenHeaders.length > 0) {\n    properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  return true;\n}\n\nfunction requestErrorSteps(xhr, event, exception) {\n  const { flag, properties, upload } = xhr;\n\n  xhr.readyState = READY_STATES.DONE;\n  properties.send = false;\n\n  setResponseToNetworkError(xhr);\n\n  if (flag.synchronous) {\n    throw exception;\n  }\n\n  fireAnEvent(\"readystatechange\", xhr);\n\n  if (!properties.uploadComplete) {\n    properties.uploadComplete = true;\n\n    if (properties.uploadListener) {\n      fireAnEvent(event, upload, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n      fireAnEvent(\"loadend\", upload, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n    }\n  }\n\n  fireAnEvent(event, xhr, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n  fireAnEvent(\"loadend\", xhr, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n}\n\nfunction setResponseToNetworkError(xhr) {\n  const { properties } = xhr;\n\n  properties.responseBuffer =\n    properties.responseCache =\n    properties.responseTextCache =\n    properties.responseXMLCache = null;\n\n  properties.responseHeaders = {};\n  xhr.status = 0;\n  xhr.statusText = \"\";\n}\n\n// return a \"request\" client object or an event emitter matching the same behaviour for unsupported protocols\n// the callback should be called with a \"request\" response object or an event emitter matching the same behaviour too\nfunction createClient(xhr) {\n  const { flag, properties } = xhr;\n  const urlObj = new URL(flag.uri);\n  const uri = urlObj.href;\n  const ucMethod = flag.method.toUpperCase();\n\n  const { requestManager } = flag;\n\n  if (urlObj.protocol === \"file:\") {\n    const response = new EventEmitter();\n    response.statusCode = 200;\n    response.rawHeaders = [];\n    response.headers = {};\n    const filePath = urlObj.pathname\n      .replace(/^file:\\/\\//, \"\")\n      .replace(/^\\/([a-z]):\\//i, \"$1:/\")\n      .replace(/%20/g, \" \");\n\n    const client = new EventEmitter();\n\n    const readableStream = fs.createReadStream(filePath, { encoding: null });\n\n    readableStream.on(\"data\", chunk => {\n      response.emit(\"data\", chunk);\n      client.emit(\"data\", chunk);\n    });\n\n    readableStream.on(\"end\", () => {\n      response.emit(\"end\");\n      client.emit(\"end\");\n    });\n\n    readableStream.on(\"error\", err => {\n      client.emit(\"error\", err);\n    });\n\n    client.abort = function () {\n      readableStream.destroy();\n      client.emit(\"abort\");\n    };\n\n    if (requestManager) {\n      const req = {\n        abort() {\n          properties.abortError = true;\n          xhr.abort();\n        }\n      };\n      requestManager.add(req);\n      const rmReq = requestManager.remove.bind(requestManager, req);\n      client.on(\"abort\", rmReq);\n      client.on(\"error\", rmReq);\n      client.on(\"end\", rmReq);\n    }\n\n    process.nextTick(() => client.emit(\"response\", response, urlObj.href));\n\n    return client;\n  }\n\n  if (urlObj.protocol === \"data:\") {\n    const response = new EventEmitter();\n\n    const client = new EventEmitter();\n\n    let buffer;\n    try {\n      const parsed = parseDataURL(uri);\n      const contentType = parsed.mimeType.toString();\n      buffer = parsed.body;\n      response.statusCode = 200;\n      response.rawHeaders = [\"Content-Type\", contentType];\n      response.headers = { \"content-type\": contentType };\n    } catch (err) {\n      process.nextTick(() => client.emit(\"error\", err));\n      return client;\n    }\n\n    client.abort = () => {\n      // do nothing\n    };\n\n    process.nextTick(() => {\n      client.emit(\"response\", response, urlObj.href);\n      process.nextTick(() => {\n        response.emit(\"data\", buffer);\n        client.emit(\"data\", buffer);\n        response.emit(\"end\");\n        client.emit(\"end\");\n      });\n    });\n\n    return client;\n  }\n  const agents = agentFactory(flag.proxy, flag.strictSSL);\n  const requestHeaders = {};\n\n  for (const header in flag.requestHeaders) {\n    requestHeaders[header] = flag.requestHeaders[header];\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"referer\") === null) {\n    requestHeaders.Referer = flag.referrer;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"user-agent\") === null) {\n    requestHeaders[\"User-Agent\"] = flag.userAgent;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept-language\") === null) {\n    requestHeaders[\"Accept-Language\"] = \"en\";\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept\") === null) {\n    requestHeaders.Accept = \"*/*\";\n  }\n\n  const crossOrigin = flag.origin !== urlObj.origin;\n  if (crossOrigin) {\n    requestHeaders.Origin = flag.origin;\n  }\n\n  const options = { rejectUnauthorized: flag.strictSSL, agents, followRedirects: true };\n  if (flag.auth) {\n    options.user = flag.auth.user || \"\";\n    options.pass = flag.auth.pass || \"\";\n  }\n  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {\n    options.cookieJar = flag.cookieJar;\n  }\n\n  const { body } = flag;\n  const hasBody = body !== undefined &&\n                  body !== null &&\n                  body !== \"\" &&\n                  !(ucMethod === \"HEAD\" || ucMethod === \"GET\");\n\n  if (hasBody && getRequestHeader(flag.requestHeaders, \"content-type\") === null) {\n    requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n  }\n\n  function doRequest() {\n    try {\n      let requestBody = body;\n      let len = 0;\n      if (hasBody) {\n        if (flag.formData) {\n          // TODO: implement https://html.spec.whatwg.org/#multipart-form-data\n          // directly instead of using an external library\n          requestBody = new FormData();\n          for (const entry of body) {\n            requestBody.append(entry.name, entry.value, entry.options);\n          }\n          len = requestBody.getLengthSync();\n          requestHeaders[\"Content-Type\"] = `multipart/form-data; boundary=${requestBody.getBoundary()}`;\n        } else {\n          if (typeof body === \"string\") {\n            len = Buffer.byteLength(body);\n          } else {\n            len = body.length;\n          }\n          requestBody = Buffer.isBuffer(requestBody) ? requestBody : Buffer.from(requestBody);\n        }\n        requestHeaders[\"Content-Length\"] = len;\n      }\n      requestHeaders[\"Accept-Encoding\"] = \"gzip, deflate\";\n      const requestClient = new Request(uri, options, { method: flag.method, headers: requestHeaders });\n      if (hasBody) {\n        if (flag.formData) {\n          requestBody.on(\"error\", err => {\n            requestClient.emit(\"error\", err);\n            requestClient.abort();\n          });\n          requestClient.pipeRequest(requestBody);\n        } else {\n          requestClient.write(requestBody);\n        }\n      }\n      return requestClient;\n    } catch (e) {\n      const eventEmitterclient = new EventEmitter();\n      process.nextTick(() => eventEmitterclient.emit(\"error\", e));\n      eventEmitterclient.end = () => {};\n      return eventEmitterclient;\n    }\n  }\n\n  let client;\n\n  const nonSimpleHeaders = Object.keys(flag.requestHeaders)\n    .filter(header => !simpleHeaders.has(header.toLowerCase()));\n\n  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0 || properties.uploadListener)) {\n    client = new EventEmitter();\n\n    const preflightRequestHeaders = {};\n    for (const header in requestHeaders) {\n      // the only existing request headers the cors spec allows on the preflight request are Origin and Referer\n      const lcHeader = header.toLowerCase();\n      if (lcHeader === \"origin\" || lcHeader === \"referer\") {\n        preflightRequestHeaders[header] = requestHeaders[header];\n      }\n    }\n\n    preflightRequestHeaders[\"Access-Control-Request-Method\"] = flag.method;\n    if (nonSimpleHeaders.length > 0) {\n      preflightRequestHeaders[\"Access-Control-Request-Headers\"] = nonSimpleHeaders.join(\", \");\n    }\n\n    preflightRequestHeaders[\"User-Agent\"] = flag.userAgent;\n\n    flag.preflight = true;\n\n    const rejectUnauthorized = flag.strictSSL;\n    const preflightClient = new Request(\n      uri,\n      { agents, followRedirects: false },\n      { method: \"OPTIONS\", headers: preflightRequestHeaders, rejectUnauthorized }\n    );\n\n    preflightClient.on(\"response\", resp => {\n      // don't send the real request if the preflight request returned an error\n      if (resp.statusCode < 200 || resp.statusCode > 299) {\n        client.emit(\"error\", new Error(\"Response for preflight has invalid HTTP status code \" + resp.statusCode));\n        return;\n      }\n      // don't send the real request if we aren't allowed to use the headers\n      if (!validCORSPreflightHeaders(xhr, resp, flag, properties)) {\n        setResponseToNetworkError(xhr);\n        return;\n      }\n      // Set request gzip option right before headers are set\n      const realClient = doRequest();\n      realClient.on(\"response\", (...args) => client.emit(\"response\", ...args));\n      realClient.on(\"data\", chunk => client.emit(\"data\", chunk));\n      realClient.on(\"end\", () => client.emit(\"end\"));\n      realClient.on(\"abort\", () => client.emit(\"abort\"));\n      realClient.on(\"request\", req => {\n        client.headers = realClient.headers;\n        client.emit(\"request\", req);\n      });\n      realClient.on(\"redirect\", (...args) => {\n        client.emit(\"redirect\", ...args);\n      });\n      realClient.on(\"error\", err => {\n        client.emit(\"error\", err);\n      });\n      client.abort = () => {\n        realClient.abort();\n      };\n      setImmediate(() => realClient.end());\n    });\n\n    preflightClient.on(\"error\", err => {\n      client.emit(\"error\", err);\n    });\n\n    client.abort = () => {\n      preflightClient.abort();\n    };\n    setImmediate(() => preflightClient.end());\n  } else {\n    client = doRequest();\n    setImmediate(() => client.end());\n  }\n\n  if (requestManager) {\n    const req = {\n      abort() {\n        properties.abortError = true;\n        xhr.abort();\n      }\n    };\n    requestManager.add(req);\n    const rmReq = requestManager.remove.bind(requestManager, req);\n    client.on(\"abort\", rmReq);\n    client.on(\"error\", rmReq);\n    client.on(\"end\", rmReq);\n  }\n  return client;\n}\n\nexports.headerListSeparatorRegexp = headerListSeparatorRegexp;\nexports.simpleHeaders = simpleHeaders;\nexports.preflightHeaders = preflightHeaders;\nexports.getRequestHeader = getRequestHeader;\nexports.updateRequestHeader = updateRequestHeader;\nexports.dispatchError = dispatchError;\nexports.validCORSHeaders = validCORSHeaders;\nexports.requestErrorSteps = requestErrorSteps;\nexports.setResponseToNetworkError = setResponseToNetworkError;\nexports.createClient = createClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}