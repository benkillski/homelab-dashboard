{"ast":null,"code":"'use strict';\n\nmodule.exports = class SymbolTreeNode {\n  constructor() {\n    this.parent = null;\n    this.previousSibling = null;\n    this.nextSibling = null;\n    this.firstChild = null;\n    this.lastChild = null;\n\n    /** This value is incremented anytime a children is added or removed */\n    this.childrenVersion = 0;\n    /** The last child object which has a cached index */\n    this.childIndexCachedUpTo = null;\n\n    /** This value represents the cached node index, as long as\n     * cachedIndexVersion matches with the childrenVersion of the parent */\n    this.cachedIndex = -1;\n    this.cachedIndexVersion = NaN; // NaN is never equal to anything\n  }\n  get isAttached() {\n    return Boolean(this.parent || this.previousSibling || this.nextSibling);\n  }\n  get hasChildren() {\n    return Boolean(this.firstChild);\n  }\n  childrenChanged() {\n    /* jshint -W016 */\n    // integer wrap around\n    this.childrenVersion = this.childrenVersion + 1 & 0xFFFFFFFF;\n    this.childIndexCachedUpTo = null;\n  }\n  getCachedIndex(parentNode) {\n    // (assumes parentNode is actually the parent)\n    if (this.cachedIndexVersion !== parentNode.childrenVersion) {\n      this.cachedIndexVersion = NaN;\n      // cachedIndex is no longer valid\n      return -1;\n    }\n    return this.cachedIndex; // -1 if not cached\n  }\n  setCachedIndex(parentNode, index) {\n    // (assumes parentNode is actually the parent)\n    this.cachedIndexVersion = parentNode.childrenVersion;\n    this.cachedIndex = index;\n  }\n};","map":{"version":3,"names":["module","exports","SymbolTreeNode","constructor","parent","previousSibling","nextSibling","firstChild","lastChild","childrenVersion","childIndexCachedUpTo","cachedIndex","cachedIndexVersion","NaN","isAttached","Boolean","hasChildren","childrenChanged","getCachedIndex","parentNode","setCachedIndex","index"],"sources":["D:/benki/Programming/GitHub/homelab-dashboard/client/homelab-dashboard/node_modules/symbol-tree/lib/SymbolTreeNode.js"],"sourcesContent":["'use strict';\n\nmodule.exports = class SymbolTreeNode {\n        constructor() {\n                this.parent = null;\n                this.previousSibling = null;\n                this.nextSibling = null;\n\n                this.firstChild = null;\n                this.lastChild = null;\n\n                /** This value is incremented anytime a children is added or removed */\n                this.childrenVersion = 0;\n                /** The last child object which has a cached index */\n                this.childIndexCachedUpTo = null;\n\n                /** This value represents the cached node index, as long as\n                 * cachedIndexVersion matches with the childrenVersion of the parent */\n                this.cachedIndex = -1;\n                this.cachedIndexVersion = NaN; // NaN is never equal to anything\n        }\n\n        get isAttached() {\n                return Boolean(this.parent || this.previousSibling || this.nextSibling);\n        }\n\n        get hasChildren() {\n                return Boolean(this.firstChild);\n        }\n\n        childrenChanged() {\n                /* jshint -W016 */\n                // integer wrap around\n                this.childrenVersion = (this.childrenVersion + 1) & 0xFFFFFFFF;\n                this.childIndexCachedUpTo = null;\n        }\n\n        getCachedIndex(parentNode) {\n                // (assumes parentNode is actually the parent)\n                if (this.cachedIndexVersion !== parentNode.childrenVersion) {\n                        this.cachedIndexVersion = NaN;\n                        // cachedIndex is no longer valid\n                        return -1;\n                }\n\n                return this.cachedIndex; // -1 if not cached\n        }\n\n        setCachedIndex(parentNode, index) {\n                // (assumes parentNode is actually the parent)\n                this.cachedIndexVersion = parentNode.childrenVersion;\n                this.cachedIndex = index;\n        }\n};\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,OAAO,GAAG,MAAMC,cAAc,CAAC;EAC9BC,WAAWA,CAAA,EAAG;IACN,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACC,WAAW,GAAG,IAAI;IAEvB,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB,IAAI,CAACC,SAAS,GAAG,IAAI;;IAErB;IACA,IAAI,CAACC,eAAe,GAAG,CAAC;IACxB;IACA,IAAI,CAACC,oBAAoB,GAAG,IAAI;;IAEhC;AAChB;IACgB,IAAI,CAACC,WAAW,GAAG,CAAC,CAAC;IACrB,IAAI,CAACC,kBAAkB,GAAGC,GAAG,CAAC,CAAC;EACvC;EAEA,IAAIC,UAAUA,CAAA,EAAG;IACT,OAAOC,OAAO,CAAC,IAAI,CAACX,MAAM,IAAI,IAAI,CAACC,eAAe,IAAI,IAAI,CAACC,WAAW,CAAC;EAC/E;EAEA,IAAIU,WAAWA,CAAA,EAAG;IACV,OAAOD,OAAO,CAAC,IAAI,CAACR,UAAU,CAAC;EACvC;EAEAU,eAAeA,CAAA,EAAG;IACV;IACA;IACA,IAAI,CAACR,eAAe,GAAI,IAAI,CAACA,eAAe,GAAG,CAAC,GAAI,UAAU;IAC9D,IAAI,CAACC,oBAAoB,GAAG,IAAI;EACxC;EAEAQ,cAAcA,CAACC,UAAU,EAAE;IACnB;IACA,IAAI,IAAI,CAACP,kBAAkB,KAAKO,UAAU,CAACV,eAAe,EAAE;MACpD,IAAI,CAACG,kBAAkB,GAAGC,GAAG;MAC7B;MACA,OAAO,CAAC,CAAC;IACjB;IAEA,OAAO,IAAI,CAACF,WAAW,CAAC,CAAC;EACjC;EAEAS,cAAcA,CAACD,UAAU,EAAEE,KAAK,EAAE;IAC1B;IACA,IAAI,CAACT,kBAAkB,GAAGO,UAAU,CAACV,eAAe;IACpD,IAAI,CAACE,WAAW,GAAGU,KAAK;EAChC;AACR,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}