{"ast":null,"code":"\"use strict\";\n\nconst fs = require(\"fs\");\nconst {\n  fileURLToPath\n} = require(\"url\");\nconst {\n  parseURL\n} = require(\"whatwg-url\");\nconst dataURLFromRecord = require(\"data-urls\").fromURLRecord;\nconst packageVersion = require(\"../../../../package.json\").version;\nconst agentFactory = require(\"../../living/helpers/agent-factory\");\nconst Request = require(\"../../living/helpers/http-request\");\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\nmodule.exports = class ResourceLoader {\n  constructor({\n    strictSSL = true,\n    proxy = undefined,\n    userAgent = `Mozilla/5.0 (${process.platform || \"unknown OS\"}) AppleWebKit/537.36 ` + `(KHTML, like Gecko) jsdom/${packageVersion}`\n  } = {}) {\n    this._strictSSL = strictSSL;\n    this._proxy = proxy;\n    this._userAgent = userAgent;\n  }\n  _readDataURL(urlRecord) {\n    const dataURL = dataURLFromRecord(urlRecord);\n    let timeoutId;\n    const promise = new Promise(resolve => {\n      timeoutId = setTimeout(resolve, 0, dataURL.body);\n    });\n    promise.abort = () => {\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    };\n    return promise;\n  }\n  _readFile(filePath) {\n    let readableStream, abort; // Native Promises doesn't have an \"abort\" method.\n\n    // Creating a promise for two reason:\n    //   1. fetch always return a promise.\n    //   2. We need to add an abort handler.\n    const promise = new Promise((resolve, reject) => {\n      readableStream = fs.createReadStream(filePath);\n      let data = Buffer.alloc(0);\n      abort = reject;\n      readableStream.on(\"error\", reject);\n      readableStream.on(\"data\", chunk => {\n        data = Buffer.concat([data, chunk]);\n      });\n      readableStream.on(\"end\", () => {\n        resolve(data);\n      });\n    });\n    promise.abort = () => {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      abort(error);\n    };\n    return promise;\n  }\n  fetch(urlString, {\n    accept,\n    cookieJar,\n    referrer\n  } = {}) {\n    const url = parseURL(urlString);\n    if (!url) {\n      return Promise.reject(new Error(`Tried to fetch invalid URL ${urlString}`));\n    }\n    switch (url.scheme) {\n      case \"data\":\n        {\n          return this._readDataURL(url);\n        }\n      case \"http\":\n      case \"https\":\n        {\n          const agents = agentFactory(this._proxy, this._strictSSL);\n          const headers = {\n            \"User-Agent\": this._userAgent,\n            \"Accept-Language\": \"en\",\n            \"Accept-Encoding\": \"gzip\",\n            \"Accept\": accept || \"*/*\"\n          };\n          if (referrer && !IS_BROWSER) {\n            headers.Referer = referrer;\n          }\n          const requestClient = new Request(urlString, {\n            followRedirects: true,\n            cookieJar,\n            agents\n          }, {\n            headers\n          });\n          const promise = new Promise((resolve, reject) => {\n            const accumulated = [];\n            requestClient.once(\"response\", res => {\n              promise.response = res;\n              const {\n                statusCode\n              } = res;\n              // TODO This deviates from the spec when it comes to\n              // loading resources such as images\n              if (statusCode < 200 || statusCode > 299) {\n                requestClient.abort();\n                reject(new Error(`Resource was not loaded. Status: ${statusCode}`));\n              }\n            });\n            requestClient.on(\"data\", chunk => {\n              accumulated.push(chunk);\n            });\n            requestClient.on(\"end\", () => resolve(Buffer.concat(accumulated)));\n            requestClient.on(\"error\", reject);\n          });\n          // The method fromURL in lib/api.js crashes without the following four\n          // properties defined on the Promise instance, causing the test suite to halt\n          requestClient.on(\"end\", () => {\n            promise.href = requestClient.currentURL;\n          });\n          promise.abort = requestClient.abort.bind(requestClient);\n          promise.getHeader = name => headers[name] || requestClient.getHeader(name);\n          requestClient.end();\n          return promise;\n        }\n      case \"file\":\n        {\n          try {\n            return this._readFile(fileURLToPath(urlString));\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        }\n      default:\n        {\n          return Promise.reject(new Error(`Tried to fetch URL ${urlString} with invalid scheme ${url.scheme}`));\n        }\n    }\n  }\n};","map":{"version":3,"names":["fs","require","fileURLToPath","parseURL","dataURLFromRecord","fromURLRecord","packageVersion","version","agentFactory","Request","IS_BROWSER","Object","prototype","toString","call","process","module","exports","ResourceLoader","constructor","strictSSL","proxy","undefined","userAgent","platform","_strictSSL","_proxy","_userAgent","_readDataURL","urlRecord","dataURL","timeoutId","promise","Promise","resolve","setTimeout","body","abort","clearTimeout","_readFile","filePath","readableStream","reject","createReadStream","data","Buffer","alloc","on","chunk","concat","destroy","error","Error","isAbortError","fetch","urlString","accept","cookieJar","referrer","url","scheme","agents","headers","Referer","requestClient","followRedirects","accumulated","once","res","response","statusCode","push","href","currentURL","bind","getHeader","name","end","e"],"sources":["D:/benki/Programming/GitHub/homelab-dashboard/client/homelab-dashboard/node_modules/jsdom/lib/jsdom/browser/resources/resource-loader.js"],"sourcesContent":["\"use strict\";\nconst fs = require(\"fs\");\nconst { fileURLToPath } = require(\"url\");\nconst { parseURL } = require(\"whatwg-url\");\nconst dataURLFromRecord = require(\"data-urls\").fromURLRecord;\nconst packageVersion = require(\"../../../../package.json\").version;\nconst agentFactory = require(\"../../living/helpers/agent-factory\");\nconst Request = require(\"../../living/helpers/http-request\");\n\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\n\nmodule.exports = class ResourceLoader {\n  constructor({\n    strictSSL = true,\n    proxy = undefined,\n    userAgent = `Mozilla/5.0 (${process.platform || \"unknown OS\"}) AppleWebKit/537.36 ` +\n                `(KHTML, like Gecko) jsdom/${packageVersion}`\n  } = {}) {\n    this._strictSSL = strictSSL;\n    this._proxy = proxy;\n    this._userAgent = userAgent;\n  }\n\n  _readDataURL(urlRecord) {\n    const dataURL = dataURLFromRecord(urlRecord);\n    let timeoutId;\n    const promise = new Promise(resolve => {\n      timeoutId = setTimeout(resolve, 0, dataURL.body);\n    });\n    promise.abort = () => {\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    };\n    return promise;\n  }\n\n  _readFile(filePath) {\n    let readableStream, abort; // Native Promises doesn't have an \"abort\" method.\n\n    // Creating a promise for two reason:\n    //   1. fetch always return a promise.\n    //   2. We need to add an abort handler.\n    const promise = new Promise((resolve, reject) => {\n      readableStream = fs.createReadStream(filePath);\n      let data = Buffer.alloc(0);\n\n      abort = reject;\n\n      readableStream.on(\"error\", reject);\n\n      readableStream.on(\"data\", chunk => {\n        data = Buffer.concat([data, chunk]);\n      });\n\n      readableStream.on(\"end\", () => {\n        resolve(data);\n      });\n    });\n\n    promise.abort = () => {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      abort(error);\n    };\n\n    return promise;\n  }\n\n  fetch(urlString, { accept, cookieJar, referrer } = {}) {\n    const url = parseURL(urlString);\n\n    if (!url) {\n      return Promise.reject(new Error(`Tried to fetch invalid URL ${urlString}`));\n    }\n\n    switch (url.scheme) {\n      case \"data\": {\n        return this._readDataURL(url);\n      }\n\n      case \"http\":\n      case \"https\": {\n        const agents = agentFactory(this._proxy, this._strictSSL);\n        const headers = {\n          \"User-Agent\": this._userAgent,\n          \"Accept-Language\": \"en\",\n          \"Accept-Encoding\": \"gzip\",\n          \"Accept\": accept || \"*/*\"\n        };\n        if (referrer && !IS_BROWSER) {\n          headers.Referer = referrer;\n        }\n        const requestClient = new Request(\n          urlString,\n          { followRedirects: true, cookieJar, agents },\n          { headers }\n        );\n        const promise = new Promise((resolve, reject) => {\n          const accumulated = [];\n          requestClient.once(\"response\", res => {\n            promise.response = res;\n            const { statusCode } = res;\n            // TODO This deviates from the spec when it comes to\n            // loading resources such as images\n            if (statusCode < 200 || statusCode > 299) {\n              requestClient.abort();\n              reject(new Error(`Resource was not loaded. Status: ${statusCode}`));\n            }\n          });\n          requestClient.on(\"data\", chunk => {\n            accumulated.push(chunk);\n          });\n          requestClient.on(\"end\", () => resolve(Buffer.concat(accumulated)));\n          requestClient.on(\"error\", reject);\n        });\n        // The method fromURL in lib/api.js crashes without the following four\n        // properties defined on the Promise instance, causing the test suite to halt\n        requestClient.on(\"end\", () => {\n          promise.href = requestClient.currentURL;\n        });\n        promise.abort = requestClient.abort.bind(requestClient);\n        promise.getHeader = name => headers[name] || requestClient.getHeader(name);\n        requestClient.end();\n        return promise;\n      }\n\n      case \"file\": {\n        try {\n          return this._readFile(fileURLToPath(urlString));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n\n      default: {\n        return Promise.reject(new Error(`Tried to fetch URL ${urlString} with invalid scheme ${url.scheme}`));\n      }\n    }\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}