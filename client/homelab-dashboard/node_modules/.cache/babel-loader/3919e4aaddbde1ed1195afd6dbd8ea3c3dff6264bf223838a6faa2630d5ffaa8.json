{"ast":null,"code":"\"use strict\";\n\nconst {\n  domSymbolTree\n} = require(\"./internal-constants\");\nconst {\n  HTML_NS\n} = require(\"./namespaces\");\n\n// All these operate on and return impls, not wrappers!\n\nexports.closest = (e, localName, namespace = HTML_NS) => {\n  while (e) {\n    if (e.localName === localName && e.namespaceURI === namespace) {\n      return e;\n    }\n    e = domSymbolTree.parent(e);\n  }\n  return null;\n};\nexports.childrenByLocalName = (parent, localName, namespace = HTML_NS) => {\n  return domSymbolTree.childrenToArray(parent, {\n    filter(node) {\n      return node._localName === localName && node._namespaceURI === namespace;\n    }\n  });\n};\nexports.descendantsByLocalName = (parent, localName, namespace = HTML_NS) => {\n  return domSymbolTree.treeToArray(parent, {\n    filter(node) {\n      return node._localName === localName && node._namespaceURI === namespace && node !== parent;\n    }\n  });\n};\nexports.childrenByLocalNames = (parent, localNamesSet, namespace = HTML_NS) => {\n  return domSymbolTree.childrenToArray(parent, {\n    filter(node) {\n      return localNamesSet.has(node._localName) && node._namespaceURI === namespace;\n    }\n  });\n};\nexports.descendantsByLocalNames = (parent, localNamesSet, namespace = HTML_NS) => {\n  return domSymbolTree.treeToArray(parent, {\n    filter(node) {\n      return localNamesSet.has(node._localName) && node._namespaceURI === namespace && node !== parent;\n    }\n  });\n};\nexports.firstChildWithLocalName = (parent, localName, namespace = HTML_NS) => {\n  const iterator = domSymbolTree.childrenIterator(parent);\n  for (const child of iterator) {\n    if (child._localName === localName && child._namespaceURI === namespace) {\n      return child;\n    }\n  }\n  return null;\n};\nexports.firstChildWithLocalNames = (parent, localNamesSet, namespace = HTML_NS) => {\n  const iterator = domSymbolTree.childrenIterator(parent);\n  for (const child of iterator) {\n    if (localNamesSet.has(child._localName) && child._namespaceURI === namespace) {\n      return child;\n    }\n  }\n  return null;\n};\nexports.firstDescendantWithLocalName = (parent, localName, namespace = HTML_NS) => {\n  const iterator = domSymbolTree.treeIterator(parent);\n  for (const descendant of iterator) {\n    if (descendant._localName === localName && descendant._namespaceURI === namespace) {\n      return descendant;\n    }\n  }\n  return null;\n};","map":{"version":3,"names":["domSymbolTree","require","HTML_NS","exports","closest","e","localName","namespace","namespaceURI","parent","childrenByLocalName","childrenToArray","filter","node","_localName","_namespaceURI","descendantsByLocalName","treeToArray","childrenByLocalNames","localNamesSet","has","descendantsByLocalNames","firstChildWithLocalName","iterator","childrenIterator","child","firstChildWithLocalNames","firstDescendantWithLocalName","treeIterator","descendant"],"sources":["D:/benki/Programming/GitHub/homelab-dashboard/client/homelab-dashboard/node_modules/jsdom/lib/jsdom/living/helpers/traversal.js"],"sourcesContent":["\"use strict\";\nconst { domSymbolTree } = require(\"./internal-constants\");\nconst { HTML_NS } = require(\"./namespaces\");\n\n// All these operate on and return impls, not wrappers!\n\nexports.closest = (e, localName, namespace = HTML_NS) => {\n  while (e) {\n    if (e.localName === localName && e.namespaceURI === namespace) {\n      return e;\n    }\n    e = domSymbolTree.parent(e);\n  }\n\n  return null;\n};\n\nexports.childrenByLocalName = (parent, localName, namespace = HTML_NS) => {\n  return domSymbolTree.childrenToArray(parent, { filter(node) {\n    return node._localName === localName && node._namespaceURI === namespace;\n  } });\n};\n\nexports.descendantsByLocalName = (parent, localName, namespace = HTML_NS) => {\n  return domSymbolTree.treeToArray(parent, { filter(node) {\n    return node._localName === localName && node._namespaceURI === namespace && node !== parent;\n  } });\n};\n\nexports.childrenByLocalNames = (parent, localNamesSet, namespace = HTML_NS) => {\n  return domSymbolTree.childrenToArray(parent, { filter(node) {\n    return localNamesSet.has(node._localName) && node._namespaceURI === namespace;\n  } });\n};\n\nexports.descendantsByLocalNames = (parent, localNamesSet, namespace = HTML_NS) => {\n  return domSymbolTree.treeToArray(parent, { filter(node) {\n    return localNamesSet.has(node._localName) &&\n           node._namespaceURI === namespace &&\n           node !== parent;\n  } });\n};\n\nexports.firstChildWithLocalName = (parent, localName, namespace = HTML_NS) => {\n  const iterator = domSymbolTree.childrenIterator(parent);\n  for (const child of iterator) {\n    if (child._localName === localName && child._namespaceURI === namespace) {\n      return child;\n    }\n  }\n  return null;\n};\n\nexports.firstChildWithLocalNames = (parent, localNamesSet, namespace = HTML_NS) => {\n  const iterator = domSymbolTree.childrenIterator(parent);\n  for (const child of iterator) {\n    if (localNamesSet.has(child._localName) && child._namespaceURI === namespace) {\n      return child;\n    }\n  }\n  return null;\n};\n\nexports.firstDescendantWithLocalName = (parent, localName, namespace = HTML_NS) => {\n  const iterator = domSymbolTree.treeIterator(parent);\n  for (const descendant of iterator) {\n    if (descendant._localName === localName && descendant._namespaceURI === namespace) {\n      return descendant;\n    }\n  }\n  return null;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}