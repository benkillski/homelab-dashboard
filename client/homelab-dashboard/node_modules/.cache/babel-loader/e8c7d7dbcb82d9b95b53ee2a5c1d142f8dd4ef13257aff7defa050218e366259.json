{"ast":null,"code":"// Copyright 2012 Iris Couch, all rights reserved.\n//\n// Encode DNS messages\n\nvar util = require('util');\nvar constants = require('./constants');\nmodule.exports = {\n  'State': State\n};\nvar SECTIONS = ['question', 'answer', 'authority', 'additional'];\nfunction State() {\n  var self = this;\n  self.header = new Buffer(12);\n  self.position = 0;\n  self.question = [];\n  self.answer = [];\n  self.authority = [];\n  self.additional = [];\n  self.domains = {}; // The compression lookup table\n}\nState.prototype.toBinary = function () {\n  var self = this;\n  var bufs = [self.header];\n  self.question.forEach(function (buf) {\n    bufs.push(buf);\n  });\n  self.answer.forEach(function (buf) {\n    bufs.push(buf);\n  });\n  self.authority.forEach(function (buf) {\n    bufs.push(buf);\n  });\n  self.additional.forEach(function (buf) {\n    bufs.push(buf);\n  });\n  return Buffer.concat(bufs);\n};\nState.prototype.message = function (msg) {\n  var self = this;\n\n  // ID\n  self.header.writeUInt16BE(msg.id, 0);\n\n  // QR, opcode, AA, TC, RD\n  var byte = 0;\n  byte |= msg.type == 'response' ? 0x80 : 0x00;\n  byte |= msg.authoritative ? 0x04 : 0x00;\n  byte |= msg.truncated ? 0x02 : 0x00;\n  byte |= msg.recursion_desired ? 0x01 : 0x00;\n  var opcode_names = ['query', 'iquery', 'status', null, 'notify', 'update'],\n    opcode = opcode_names.indexOf(msg.opcode);\n  if (opcode == -1 || typeof msg.opcode != 'string') throw new Error('Unknown opcode: ' + msg.opcode);else byte |= opcode << 3;\n  self.header.writeUInt8(byte, 2);\n\n  // RA, Z, AD, CD, Rcode\n  byte = 0;\n  byte |= msg.recursion_available ? 0x80 : 0x00;\n  byte |= msg.authenticated ? 0x20 : 0x00;\n  byte |= msg.checking_disabled ? 0x10 : 0x00;\n  byte |= msg.responseCode & 0x0f;\n  self.header.writeUInt8(byte, 3);\n  self.position = 12; // the beginning of the sections\n  SECTIONS.forEach(function (section) {\n    var records = msg[section] || [];\n    records.forEach(function (rec) {\n      self.record(section, rec);\n    });\n  });\n\n  // Write the section counts.\n  self.header.writeUInt16BE(self.question.length, 4);\n  self.header.writeUInt16BE(self.answer.length, 6);\n  self.header.writeUInt16BE(self.authority.length, 8);\n  self.header.writeUInt16BE(self.additional.length, 10);\n};\nState.prototype.record = function (section_name, record) {\n  var self = this;\n  var body = [],\n    buf;\n\n  // Write the record name.\n  buf = self.encode(record.name);\n  body.push(buf);\n  self.position += buf.length;\n  var type = constants.type_to_number(record.type),\n    clas = constants.class_to_number(record.class);\n\n  // Write the type.\n  buf = new Buffer(2);\n  buf.writeUInt16BE(type, 0);\n  body.push(buf);\n  self.position += 2;\n\n  // Write the class.\n  buf = new Buffer(2);\n  buf.writeUInt16BE(clas, 0);\n  body.push(buf);\n  self.position += 2;\n  if (section_name != 'question') {\n    // Write the TTL.\n    buf = new Buffer(4);\n    buf.writeUInt32BE(record.ttl || 0, 0);\n    body.push(buf);\n    self.position += 4;\n\n    // Write the rdata. Update the position now (the rdata length value) in case self.encode() runs.\n    var match, rdata;\n    switch (record.class + ' ' + record.type) {\n      case 'IN A':\n        rdata = record.data || '';\n        match = rdata.match(/^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/);\n        if (!match) throw new Error('Bad ' + record.type + ' record data: ' + JSON.stringify(record));\n        rdata = [+match[1], +match[2], +match[3], +match[4]];\n        break;\n      case 'IN AAAA':\n        // [hbouvier] More robust parsing of ipV6 address\n        rdata = ipv6_to_array(record.data || '::');\n        if (rdata.length !== 8) throw new Error('Bad ' + record.type + ' record data: ' + JSON.stringify(record));\n        rdata = rdata.map(pair_to_buf);\n        break;\n      case 'IN MX':\n        var host = record.data[1];\n        rdata = [buf16(record.data[0]), self.encode(host, 2 + 2) // Adjust for the rdata length + preference values.\n        ];\n        break;\n      case 'IN SOA':\n        var mname = self.encode(record.data.mname, 2) // Adust for rdata length\n          ,\n          rname = self.encode(record.data.rname, 2 + mname.length);\n        rdata = [mname, rname, buf32(record.data.serial), buf32(record.data.refresh), buf32(record.data.retry), buf32(record.data.expire), buf32(record.data.ttl)];\n        break;\n      case 'IN NS':\n      case 'IN PTR':\n      case 'IN CNAME':\n        rdata = self.encode(record.data, 2); // Adjust for the rdata length\n        break;\n      case 'IN TXT':\n        rdata = record.data.map(function (part) {\n          part = new Buffer(part);\n          return [part.length, part];\n        });\n        break;\n      case 'IN SRV':\n        rdata = [buf16(record.data.priority), buf16(record.data.weight), buf16(record.data.port), self.encode(record.data.target, 2 + 6, 'nocompress') // Offset for rdata length + priority, weight, and port.\n        ];\n        break;\n      case 'IN DS':\n        rdata = [buf16(record.data.key_tag), new Buffer([record.data.algorithm]), new Buffer([record.data.digest_type]), new Buffer(record.data.digest)];\n        break;\n      case 'NONE A':\n        // I think this is no data, from RFC 2136 S. 2.4.3.\n        rdata = [];\n        break;\n      default:\n        throw new Error('Unsupported record type: ' + JSON.stringify(record));\n    }\n\n    // Write the rdata length. (The position was already updated.)\n    rdata = flat(rdata);\n    buf = new Buffer(2);\n    buf.writeUInt16BE(rdata.length, 0);\n    body.push(buf);\n    self.position += 2;\n\n    // Write the rdata.\n    self.position += rdata.length;\n    if (rdata.length > 0) body.push(new Buffer(rdata));\n  }\n  self[section_name].push(Buffer.concat(body));\n};\nState.prototype.encode = function (full_domain, position_offset, option) {\n  var self = this;\n\n  // [hbouvier] Added default value\n  var domain = full_domain || '';\n  domain = domain.replace(/\\.$/, ''); // Strip the trailing dot.\n  position = self.position + (position_offset || 0);\n  var body = [],\n    bytes;\n  var i = 0;\n  var max_iterations = 40; // Enough for 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa\n\n  while (++i < max_iterations) {\n    if (domain == '') {\n      // Encode the root domain and be done.\n      body.push(new Buffer([0]));\n      return Buffer.concat(body);\n    } else if (self.domains[domain] && option !== 'nocompress') {\n      // Encode a pointer and be done.\n      body.push(new Buffer([0xc0, self.domains[domain]]));\n      return Buffer.concat(body);\n    } else {\n      // Encode the next part of the domain, saving its position in the lookup table for later.\n      self.domains[domain] = position;\n      var parts = domain.split(/\\./),\n        car = parts[0];\n      domain = parts.slice(1).join('.');\n\n      // Write the first part of the domain, with a length prefix.\n      //var part = parts[0]\n      var buf = new Buffer(car.length + 1);\n      buf.write(car, 1, car.length, 'ascii');\n      buf.writeUInt8(car.length, 0);\n      body.push(buf);\n      position += buf.length;\n      //bytes.unshift(bytes.length)\n    }\n  }\n  throw new Error('Too many iterations encoding domain: ' + full_domain);\n};\n\n//\n// Utilities\n//\n\nfunction buf32(value) {\n  var buf = new Buffer(4);\n  buf.writeUInt32BE(value, 0);\n  return buf;\n}\nfunction buf16(value) {\n  var buf = new Buffer(2);\n  buf.writeUInt16BE(value, 0);\n  return buf;\n}\nfunction flat(data) {\n  return Buffer.isBuffer(data) ? Array.prototype.slice.call(data) : Array.isArray(data) ? data.reduce(flatten, []) : [data];\n}\nfunction flatten(state, element) {\n  return Buffer.isBuffer(element) || Array.isArray(element) ? state.concat(flat(element)) : state.concat([element]);\n}\nfunction pair_to_buf(pair) {\n  // [hbouvier]  It is possible that the \"pair\" has less than 4 digits, lets\n  //             make sure that it has.\n  var pairLength = pair.length;\n  if (pairLength < 4) pair = \"0000\".substring(pairLength) + pair;\n\n  // Convert a string of two hex bytes, e.g. \"89ab\" to a buffer.\n  if (!pair.match(/^[0-9a-fA-F]{4}$/)) throw new Error('Bad ' + record.type + ' record data: ' + JSON.stringify(record));\n  return new Buffer(pair, 'hex');\n}\n\n// [hbouvier] More robust parsing of ipV6 address\nfunction ipv6_to_array(string) {\n  var fullAddress = ['0', '0', '0', '0', '0', '0', '0', '0'];\n  // Remove the contiguous empty strings generated by '::' and keep ony one.\n  var numbers = string.split(/:/).reduce(function (previous, current) {\n    if (previous instanceof Array === false) previous = [previous];\n    if (!(current === '' && previous[previous.length - 1] === '')) {\n      previous.push(current);\n    }\n    return previous;\n  });\n  // Replace the single empty string, by the number of '0' that\n  // were \"missing\" (e.g. shortened address)\n  var merged = [].concat.apply([], numbers.map(function (num) {\n    return num === '' ? fullAddress.slice(numbers.length - 1) : num;\n  }));\n  return merged;\n}","map":{"version":3,"names":["util","require","constants","module","exports","State","SECTIONS","self","header","Buffer","position","question","answer","authority","additional","domains","prototype","toBinary","bufs","forEach","buf","push","concat","message","msg","writeUInt16BE","id","byte","type","authoritative","truncated","recursion_desired","opcode_names","opcode","indexOf","Error","writeUInt8","recursion_available","authenticated","checking_disabled","responseCode","section","records","rec","record","length","section_name","body","encode","name","type_to_number","clas","class_to_number","class","writeUInt32BE","ttl","match","rdata","data","JSON","stringify","ipv6_to_array","map","pair_to_buf","host","buf16","mname","rname","buf32","serial","refresh","retry","expire","part","priority","weight","port","target","key_tag","algorithm","digest_type","digest","flat","full_domain","position_offset","option","domain","replace","bytes","i","max_iterations","parts","split","car","slice","join","write","value","isBuffer","Array","call","isArray","reduce","flatten","state","element","pair","pairLength","substring","string","fullAddress","numbers","previous","current","merged","apply","num"],"sources":["D:/benki/Programming/GitHub/homelab-dashboard/client/homelab-dashboard/node_modules/hbo-dnsd/encode.js"],"sourcesContent":["// Copyright 2012 Iris Couch, all rights reserved.\n//\n// Encode DNS messages\n\nvar util = require('util')\n\nvar constants = require('./constants')\n\nmodule.exports = { 'State': State\n                 }\n\nvar SECTIONS = ['question', 'answer', 'authority', 'additional']\n\nfunction State () {\n  var self = this\n\n  self.header = new Buffer(12)\n  self.position = 0\n\n  self.question   = []\n  self.answer     = []\n  self.authority  = []\n  self.additional = []\n\n  self.domains = {} // The compression lookup table\n}\n\nState.prototype.toBinary = function() {\n  var self = this\n\n  var bufs = [self.header]\n  self.question  .forEach(function(buf) { bufs.push(buf) })\n  self.answer    .forEach(function(buf) { bufs.push(buf) })\n  self.authority .forEach(function(buf) { bufs.push(buf) })\n  self.additional.forEach(function(buf) { bufs.push(buf) })\n\n  return Buffer.concat(bufs)\n}\n\nState.prototype.message = function(msg) {\n  var self = this\n\n  // ID\n  self.header.writeUInt16BE(msg.id, 0)\n\n  // QR, opcode, AA, TC, RD\n  var byte = 0\n  byte |= msg.type == 'response' ? 0x80 : 0x00\n  byte |= msg.authoritative      ? 0x04 : 0x00\n  byte |= msg.truncated          ? 0x02 : 0x00\n  byte |= msg.recursion_desired  ? 0x01 : 0x00\n\n  var opcode_names = ['query', 'iquery', 'status', null, 'notify', 'update']\n    , opcode = opcode_names.indexOf(msg.opcode)\n\n  if(opcode == -1 || typeof msg.opcode != 'string')\n    throw new Error('Unknown opcode: ' + msg.opcode)\n  else\n    byte |= (opcode << 3)\n\n  self.header.writeUInt8(byte, 2)\n\n  // RA, Z, AD, CD, Rcode\n  byte = 0\n  byte |= msg.recursion_available ? 0x80 : 0x00\n  byte |= msg.authenticated       ? 0x20 : 0x00\n  byte |= msg.checking_disabled   ? 0x10 : 0x00\n  byte |= (msg.responseCode & 0x0f)\n\n  self.header.writeUInt8(byte, 3)\n\n  self.position = 12 // the beginning of the sections\n  SECTIONS.forEach(function(section) {\n    var records = msg[section] || []\n    records.forEach(function(rec) {\n      self.record(section, rec)\n    })\n  })\n\n  // Write the section counts.\n  self.header.writeUInt16BE(self.question.length    , 4)\n  self.header.writeUInt16BE(self.answer.length      , 6)\n  self.header.writeUInt16BE(self.authority.length   , 8)\n  self.header.writeUInt16BE(self.additional.length  , 10)\n}\n\nState.prototype.record = function(section_name, record) {\n  var self = this\n\n  var body = []\n    , buf\n\n  // Write the record name.\n  buf = self.encode(record.name)\n  body.push(buf)\n  self.position += buf.length\n\n  var type = constants.type_to_number(record.type)\n    , clas = constants.class_to_number(record.class)\n\n  // Write the type.\n  buf = new Buffer(2)\n  buf.writeUInt16BE(type, 0)\n  body.push(buf)\n  self.position += 2\n\n  // Write the class.\n  buf = new Buffer(2)\n  buf.writeUInt16BE(clas, 0)\n  body.push(buf)\n  self.position += 2\n\n  if(section_name != 'question') {\n    // Write the TTL.\n    buf = new Buffer(4)\n    buf.writeUInt32BE(record.ttl || 0, 0)\n    body.push(buf)\n    self.position += 4\n\n    // Write the rdata. Update the position now (the rdata length value) in case self.encode() runs.\n    var match, rdata\n    switch (record.class + ' ' + record.type) {\n      case 'IN A':\n        rdata = record.data || ''\n        match = rdata.match(/^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/)\n        if(!match)\n          throw new Error('Bad '+record.type+' record data: ' + JSON.stringify(record))\n        rdata = [ +match[1], +match[2], +match[3], +match[4] ]\n        break\n      case 'IN AAAA':\n        // [hbouvier] More robust parsing of ipV6 address\n        rdata = ipv6_to_array(record.data || '::')\n        if(rdata.length !== 8)\n          throw new Error('Bad '+record.type+' record data: ' + JSON.stringify(record))\n        rdata = rdata.map(pair_to_buf)\n        break\n      case 'IN MX':\n        var host = record.data[1]\n        rdata = [ buf16(record.data[0])\n                , self.encode(host, 2 + 2) // Adjust for the rdata length + preference values.\n                ]\n        break\n      case 'IN SOA':\n        var mname   = self.encode(record.data.mname, 2) // Adust for rdata length\n          , rname   = self.encode(record.data.rname, 2 + mname.length)\n        rdata = [ mname\n                , rname\n                , buf32(record.data.serial)\n                , buf32(record.data.refresh)\n                , buf32(record.data.retry)\n                , buf32(record.data.expire)\n                , buf32(record.data.ttl)\n                ]\n        break\n      case 'IN NS':\n      case 'IN PTR':\n      case 'IN CNAME':\n        rdata = self.encode(record.data, 2) // Adjust for the rdata length\n        break\n      case 'IN TXT':\n        rdata = record.data.map(function(part) {\n          part = new Buffer(part)\n          return [part.length, part]\n        })\n        break\n      case 'IN SRV':\n        rdata = [ buf16(record.data.priority)\n                , buf16(record.data.weight)\n                , buf16(record.data.port)\n                , self.encode(record.data.target, 2 + 6, 'nocompress') // Offset for rdata length + priority, weight, and port.\n                ]\n        break\n      case 'IN DS':\n        rdata = [ buf16(record.data.key_tag)\n                , new Buffer([record.data.algorithm])\n                , new Buffer([record.data.digest_type])\n                , new Buffer(record.data.digest)\n                ]\n        break\n      case 'NONE A':\n        // I think this is no data, from RFC 2136 S. 2.4.3.\n        rdata = []\n        break\n      default:\n        throw new Error('Unsupported record type: ' + JSON.stringify(record))\n    }\n\n    // Write the rdata length. (The position was already updated.)\n    rdata = flat(rdata)\n    buf = new Buffer(2)\n    buf.writeUInt16BE(rdata.length, 0)\n    body.push(buf)\n    self.position += 2\n\n    // Write the rdata.\n    self.position += rdata.length\n    if(rdata.length > 0)\n      body.push(new Buffer(rdata))\n  }\n\n  self[section_name].push(Buffer.concat(body))\n}\n\nState.prototype.encode = function(full_domain, position_offset, option) {\n  var self = this\n\n  // [hbouvier] Added default value\n  var domain = full_domain || '';\n  domain = domain.replace(/\\.$/, '') // Strip the trailing dot.\n  position = self.position + (position_offset || 0)\n\n  var body = []\n    , bytes\n\n  var i = 0\n  var max_iterations = 40 // Enough for 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa\n\n  while(++i < max_iterations) {\n    if(domain == '') {\n      // Encode the root domain and be done.\n      body.push(new Buffer([0]))\n      return Buffer.concat(body)\n    }\n\n    else if(self.domains[domain] && option !== 'nocompress') {\n      // Encode a pointer and be done.\n      body.push(new Buffer([0xc0, self.domains[domain]]))\n      return Buffer.concat(body)\n    }\n\n    else {\n      // Encode the next part of the domain, saving its position in the lookup table for later.\n      self.domains[domain] = position\n\n      var parts = domain.split(/\\./)\n        , car = parts[0]\n      domain = parts.slice(1).join('.')\n\n      // Write the first part of the domain, with a length prefix.\n      //var part = parts[0]\n      var buf = new Buffer(car.length + 1)\n      buf.write(car, 1, car.length, 'ascii')\n      buf.writeUInt8(car.length, 0)\n      body.push(buf)\n      position += buf.length\n      //bytes.unshift(bytes.length)\n    }\n  }\n\n  throw new Error('Too many iterations encoding domain: ' + full_domain)\n}\n\n\n//\n// Utilities\n//\n\nfunction buf32(value) {\n  var buf = new Buffer(4)\n  buf.writeUInt32BE(value, 0)\n  return buf\n}\n\nfunction buf16(value) {\n  var buf = new Buffer(2)\n  buf.writeUInt16BE(value, 0)\n  return buf\n}\n\nfunction flat(data) {\n  return Buffer.isBuffer(data)\n          ? Array.prototype.slice.call(data)\n          : Array.isArray(data)\n            ? data.reduce(flatten, [])\n            : [data]\n}\n\nfunction flatten(state, element) {\n  return (Buffer.isBuffer(element) || Array.isArray(element))\n          ? state.concat(flat(element))\n          : state.concat([element])\n}\n\nfunction pair_to_buf(pair) {\n  // [hbouvier]  It is possible that the \"pair\" has less than 4 digits, lets\n  //             make sure that it has.\n  var pairLength = pair.length;\n  if (pairLength < 4)\n    pair = \"0000\".substring(pairLength) + pair;\n\n  // Convert a string of two hex bytes, e.g. \"89ab\" to a buffer.\n  if(! pair.match(/^[0-9a-fA-F]{4}$/))\n    throw new Error('Bad '+record.type+' record data: ' + JSON.stringify(record))\n  return new Buffer(pair, 'hex')\n}\n\n// [hbouvier] More robust parsing of ipV6 address\nfunction ipv6_to_array(string) {\n  var fullAddress = ['0','0','0','0','0','0','0','0'];\n  // Remove the contiguous empty strings generated by '::' and keep ony one.\n  var numbers = string.split(/:/).reduce(function (previous, current) {\n    if (previous instanceof Array === false)\n      previous = [previous];\n    if (!(current === '' && previous[previous.length -1] === '')) {\n      previous.push(current)\n    }\n    return previous;\n  });\n  // Replace the single empty string, by the number of '0' that\n  // were \"missing\" (e.g. shortened address)\n  var merged = [].concat.apply([], numbers.map(function (num) {\n    return (num === '') ? fullAddress.slice(numbers.length -1): num;\n  }));\n  return merged;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}