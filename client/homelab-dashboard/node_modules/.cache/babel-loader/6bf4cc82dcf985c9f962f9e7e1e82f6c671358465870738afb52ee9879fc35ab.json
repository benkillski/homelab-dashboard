{"ast":null,"code":"/**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */\n\nvar Url = require(\"url\");\nvar spawn = require(\"child_process\").spawn;\nvar fs = require(\"fs\");\nexports.XMLHttpRequest = function () {\n  \"use strict\";\n\n  /**\n   * Private variables\n   */\n  var self = this;\n  var http = require(\"http\");\n  var https = require(\"https\");\n\n  // Holds http.js objects\n  var request;\n  var response;\n\n  // Request settings\n  var settings = {};\n\n  // Disable header blacklist.\n  // Not part of XHR specs.\n  var disableHeaderCheck = false;\n\n  // Set some default headers\n  var defaultHeaders = {\n    \"User-Agent\": \"node-XMLHttpRequest\",\n    \"Accept\": \"*/*\"\n  };\n  var headers = {};\n  var headersCase = {};\n\n  // These headers are not user setable.\n  // The following are allowed but banned in the spec:\n  // * user-agent\n  var forbiddenRequestHeaders = [\"accept-charset\", \"accept-encoding\", \"access-control-request-headers\", \"access-control-request-method\", \"connection\", \"content-length\", \"content-transfer-encoding\", \"cookie\", \"cookie2\", \"date\", \"expect\", \"host\", \"keep-alive\", \"origin\", \"referer\", \"te\", \"trailer\", \"transfer-encoding\", \"upgrade\", \"via\"];\n\n  // These request methods are not allowed\n  var forbiddenRequestMethods = [\"TRACE\", \"TRACK\", \"CONNECT\"];\n\n  // Send flag\n  var sendFlag = false;\n  // Error flag, used when errors occur or abort is called\n  var errorFlag = false;\n\n  // Event listeners\n  var listeners = {};\n\n  /**\n   * Constants\n   */\n\n  this.UNSENT = 0;\n  this.OPENED = 1;\n  this.HEADERS_RECEIVED = 2;\n  this.LOADING = 3;\n  this.DONE = 4;\n\n  /**\n   * Public vars\n   */\n\n  // Current state\n  this.readyState = this.UNSENT;\n\n  // default ready state change handler in case one is not set or is set late\n  this.onreadystatechange = null;\n\n  // Result & response\n  this.responseText = \"\";\n  this.responseXML = \"\";\n  this.status = null;\n  this.statusText = null;\n\n  // Whether cross-site Access-Control requests should be made using\n  // credentials such as cookies or authorization headers\n  this.withCredentials = false;\n\n  /**\n   * Private methods\n   */\n\n  /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpHeader = function (header) {\n    return disableHeaderCheck || header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1;\n  };\n\n  /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpMethod = function (method) {\n    return method && forbiddenRequestMethods.indexOf(method) === -1;\n  };\n\n  /**\n   * Public methods\n   */\n\n  /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */\n  this.open = function (method, url, async, user, password) {\n    this.abort();\n    errorFlag = false;\n\n    // Check for valid request method\n    if (!isAllowedHttpMethod(method)) {\n      throw new Error(\"SecurityError: Request method not allowed\");\n    }\n    settings = {\n      \"method\": method,\n      \"url\": url.toString(),\n      \"async\": typeof async !== \"boolean\" ? true : async,\n      \"user\": user || null,\n      \"password\": password || null\n    };\n    setState(this.OPENED);\n  };\n\n  /**\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\n   * This does not conform to the W3C spec.\n   *\n   * @param boolean state Enable or disable header checking.\n   */\n  this.setDisableHeaderCheck = function (state) {\n    disableHeaderCheck = state;\n  };\n\n  /**\n   * Sets a header for the request or appends the value if one is already set.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   */\n  this.setRequestHeader = function (header, value) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\");\n    }\n    if (!isAllowedHttpHeader(header)) {\n      console.warn(\"Refused to set unsafe header \\\"\" + header + \"\\\"\");\n      return;\n    }\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send flag is true\");\n    }\n    header = headersCase[header.toLowerCase()] || header;\n    headersCase[header.toLowerCase()] = header;\n    headers[header] = headers[header] ? headers[header] + ', ' + value : value;\n  };\n\n  /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn't exist.\n   */\n  this.getResponseHeader = function (header) {\n    if (typeof header === \"string\" && this.readyState > this.OPENED && response && response.headers && response.headers[header.toLowerCase()] && !errorFlag) {\n      return response.headers[header.toLowerCase()];\n    }\n    return null;\n  };\n\n  /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */\n  this.getAllResponseHeaders = function () {\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n      return \"\";\n    }\n    var result = \"\";\n    for (var i in response.headers) {\n      // Cookie headers are excluded\n      if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n        result += i + \": \" + response.headers[i] + \"\\r\\n\";\n      }\n    }\n    return result.substr(0, result.length - 2);\n  };\n\n  /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */\n  this.getRequestHeader = function (name) {\n    if (typeof name === \"string\" && headersCase[name.toLowerCase()]) {\n      return headers[headersCase[name.toLowerCase()]];\n    }\n    return \"\";\n  };\n\n  /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */\n  this.send = function (data) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: connection must be opened before send() is called\");\n    }\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send has already been called\");\n    }\n    var ssl = false,\n      local = false;\n    var url = Url.parse(settings.url);\n    var host;\n    // Determine the server\n    switch (url.protocol) {\n      case \"https:\":\n        ssl = true;\n      // SSL & non-SSL both need host, no break here.\n      case \"http:\":\n        host = url.hostname;\n        break;\n      case \"file:\":\n        local = true;\n        break;\n      case undefined:\n      case null:\n      case \"\":\n        host = \"localhost\";\n        break;\n      default:\n        throw new Error(\"Protocol not supported.\");\n    }\n\n    // Load files off the local filesystem (file://)\n    if (local) {\n      if (settings.method !== \"GET\") {\n        throw new Error(\"XMLHttpRequest: Only GET method is supported\");\n      }\n      if (settings.async) {\n        fs.readFile(url.pathname, \"utf8\", function (error, data) {\n          if (error) {\n            self.handleError(error);\n          } else {\n            self.status = 200;\n            self.responseText = data;\n            setState(self.DONE);\n          }\n        });\n      } else {\n        try {\n          this.responseText = fs.readFileSync(url.pathname, \"utf8\");\n          this.status = 200;\n          setState(self.DONE);\n        } catch (e) {\n          this.handleError(e);\n        }\n      }\n      return;\n    }\n\n    // Default to port 80. If accessing localhost on another port be sure\n    // to use http://localhost:port/path\n    var port = url.port || (ssl ? 443 : 80);\n    // Add query string if one is used\n    var uri = url.pathname + (url.search ? url.search : \"\");\n\n    // Set the defaults if they haven't been set\n    for (var name in defaultHeaders) {\n      if (!headersCase[name.toLowerCase()]) {\n        headers[name] = defaultHeaders[name];\n      }\n    }\n\n    // Set the Host header or the server may reject the request\n    headers.Host = host;\n    if (!(ssl && port === 443 || port === 80)) {\n      headers.Host += \":\" + url.port;\n    }\n\n    // Set Basic Auth if necessary\n    if (settings.user) {\n      if (typeof settings.password === \"undefined\") {\n        settings.password = \"\";\n      }\n      var authBuf = new Buffer(settings.user + \":\" + settings.password);\n      headers.Authorization = \"Basic \" + authBuf.toString(\"base64\");\n    }\n\n    // Set content length header\n    if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n      data = null;\n    } else if (data) {\n      headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n    } else if (settings.method === \"POST\") {\n      // For a post with no data set Content-Length: 0.\n      // This is required by buggy servers that don't meet the specs.\n      headers[\"Content-Length\"] = 0;\n    }\n    var options = {\n      host: host,\n      port: port,\n      path: uri,\n      method: settings.method,\n      headers: headers,\n      agent: false,\n      withCredentials: self.withCredentials\n    };\n\n    // Reset error flag\n    errorFlag = false;\n\n    // Handle async requests\n    if (settings.async) {\n      // Use the proper protocol\n      var doRequest = ssl ? https.request : http.request;\n\n      // Request is being sent, set send flag\n      sendFlag = true;\n\n      // As per spec, this is called here for historical reasons.\n      self.dispatchEvent(\"readystatechange\");\n\n      // Handler for the response\n      var responseHandler = function responseHandler(resp) {\n        // Set response var to the response we got back\n        // This is so it remains accessable outside this scope\n        response = resp;\n        // Check for redirect\n        // @TODO Prevent looped redirects\n        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\n          // Change URL to the redirect location\n          settings.url = response.headers.location;\n          var url = Url.parse(settings.url);\n          // Set host var in case it's used later\n          host = url.hostname;\n          // Options for the new request\n          var newOptions = {\n            hostname: url.hostname,\n            port: url.port,\n            path: url.path,\n            method: response.statusCode === 303 ? \"GET\" : settings.method,\n            headers: headers,\n            withCredentials: self.withCredentials\n          };\n\n          // Issue the new request\n          request = doRequest(newOptions, responseHandler).on(\"error\", errorHandler);\n          request.end();\n          // @TODO Check if an XHR event needs to be fired here\n          return;\n        }\n        response.setEncoding(\"utf8\");\n        setState(self.HEADERS_RECEIVED);\n        self.status = response.statusCode;\n        response.on(\"data\", function (chunk) {\n          // Make sure there's some data\n          if (chunk) {\n            self.responseText += chunk;\n          }\n          // Don't emit state changes if the connection has been aborted.\n          if (sendFlag) {\n            setState(self.LOADING);\n          }\n        });\n        response.on(\"end\", function () {\n          if (sendFlag) {\n            // Discard the end event if the connection has been aborted\n            setState(self.DONE);\n            sendFlag = false;\n          }\n        });\n        response.on(\"error\", function (error) {\n          self.handleError(error);\n        });\n      };\n\n      // Error handler for the request\n      var errorHandler = function errorHandler(error) {\n        self.handleError(error);\n      };\n\n      // Create the request\n      request = doRequest(options, responseHandler).on(\"error\", errorHandler);\n\n      // Node 0.4 and later won't accept empty data. Make sure it's needed.\n      if (data) {\n        request.write(data);\n      }\n      request.end();\n      self.dispatchEvent(\"loadstart\");\n    } else {\n      // Synchronous\n      // Create a temporary file for communication with the other Node process\n      var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\n      var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n      fs.writeFileSync(syncFile, \"\", \"utf8\");\n      // The async request the other Node process executes\n      var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\" + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\" + \"var options = \" + JSON.stringify(options) + \";\" + \"var responseText = '';\" + \"var req = doRequest(options, function(response) {\" + \"response.setEncoding('utf8');\" + \"response.on('data', function(chunk) {\" + \"  responseText += chunk;\" + \"});\" + \"response.on('end', function() {\" + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + \"response.on('error', function(error) {\" + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: error}), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + \"}).on('error', function(error) {\" + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: error}), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + (data ? \"req.write('\" + JSON.stringify(data).slice(1, -1).replace(/'/g, \"\\\\'\") + \"');\" : \"\") + \"req.end();\";\n      // Start the other Node Process, executing this string\n      var syncProc = spawn(process.argv[0], [\"-e\", execString]);\n      while (fs.existsSync(syncFile)) {\n        // Wait while the sync file is empty\n      }\n      var resp = JSON.parse(fs.readFileSync(contentFile, 'utf8'));\n      // Kill the child process once the file has data\n      syncProc.stdin.end();\n      // Remove the temporary file\n      fs.unlinkSync(contentFile);\n      if (resp.err) {\n        self.handleError(resp.err);\n      } else {\n        response = resp.data;\n        self.status = resp.data.statusCode;\n        self.responseText = resp.data.text;\n        setState(self.DONE);\n      }\n    }\n  };\n\n  /**\n   * Called when an error is encountered to deal with it.\n   */\n  this.handleError = function (error) {\n    this.status = 0;\n    this.statusText = error;\n    this.responseText = error.stack;\n    errorFlag = true;\n    setState(this.DONE);\n    this.dispatchEvent('error');\n  };\n\n  /**\n   * Aborts a request.\n   */\n  this.abort = function () {\n    if (request) {\n      request.abort();\n      request = null;\n    }\n    headers = defaultHeaders;\n    this.status = 0;\n    this.responseText = \"\";\n    this.responseXML = \"\";\n    errorFlag = true;\n    if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {\n      sendFlag = false;\n      setState(this.DONE);\n    }\n    this.readyState = this.UNSENT;\n    this.dispatchEvent('abort');\n  };\n\n  /**\n   * Adds an event listener. Preferred method of binding to events.\n   */\n  this.addEventListener = function (event, callback) {\n    if (!(event in listeners)) {\n      listeners[event] = [];\n    }\n    // Currently allows duplicate callbacks. Should it?\n    listeners[event].push(callback);\n  };\n\n  /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */\n  this.removeEventListener = function (event, callback) {\n    if (event in listeners) {\n      // Filter will return a new array with the callback removed\n      listeners[event] = listeners[event].filter(function (ev) {\n        return ev !== callback;\n      });\n    }\n  };\n\n  /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */\n  this.dispatchEvent = function (event) {\n    if (typeof self[\"on\" + event] === \"function\") {\n      self[\"on\" + event]();\n    }\n    if (event in listeners) {\n      for (var i = 0, len = listeners[event].length; i < len; i++) {\n        listeners[event][i].call(self);\n      }\n    }\n  };\n\n  /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */\n  var setState = function (state) {\n    if (state == self.LOADING || self.readyState !== state) {\n      self.readyState = state;\n      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n        self.dispatchEvent(\"readystatechange\");\n      }\n      if (self.readyState === self.DONE && !errorFlag) {\n        self.dispatchEvent(\"load\");\n        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n        self.dispatchEvent(\"loadend\");\n      }\n    }\n  };\n};","map":{"version":3,"names":["Url","require","spawn","fs","exports","XMLHttpRequest","self","http","https","request","response","settings","disableHeaderCheck","defaultHeaders","headers","headersCase","forbiddenRequestHeaders","forbiddenRequestMethods","sendFlag","errorFlag","listeners","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","readyState","onreadystatechange","responseText","responseXML","status","statusText","withCredentials","isAllowedHttpHeader","header","indexOf","toLowerCase","isAllowedHttpMethod","method","open","url","async","user","password","abort","Error","toString","setState","setDisableHeaderCheck","state","setRequestHeader","value","console","warn","getResponseHeader","getAllResponseHeaders","result","i","substr","length","getRequestHeader","name","send","data","ssl","local","parse","host","protocol","hostname","undefined","readFile","pathname","error","handleError","readFileSync","e","port","uri","search","Host","authBuf","Buffer","Authorization","isBuffer","byteLength","options","path","agent","doRequest","dispatchEvent","responseHandler","resp","statusCode","location","newOptions","on","errorHandler","end","setEncoding","chunk","write","contentFile","process","pid","syncFile","writeFileSync","execString","JSON","stringify","slice","replace","syncProc","argv","existsSync","stdin","unlinkSync","err","text","stack","addEventListener","event","callback","push","removeEventListener","filter","ev","len","call"],"sources":["D:/benki/Programming/GitHub/homelab-dashboard/client/homelab-dashboard/node_modules/xmlhttprequest/lib/XMLHttpRequest.js"],"sourcesContent":["/**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */\n\nvar Url = require(\"url\");\nvar spawn = require(\"child_process\").spawn;\nvar fs = require(\"fs\");\n\nexports.XMLHttpRequest = function() {\n  \"use strict\";\n\n  /**\n   * Private variables\n   */\n  var self = this;\n  var http = require(\"http\");\n  var https = require(\"https\");\n\n  // Holds http.js objects\n  var request;\n  var response;\n\n  // Request settings\n  var settings = {};\n\n  // Disable header blacklist.\n  // Not part of XHR specs.\n  var disableHeaderCheck = false;\n\n  // Set some default headers\n  var defaultHeaders = {\n    \"User-Agent\": \"node-XMLHttpRequest\",\n    \"Accept\": \"*/*\",\n  };\n\n  var headers = {};\n  var headersCase = {};\n\n  // These headers are not user setable.\n  // The following are allowed but banned in the spec:\n  // * user-agent\n  var forbiddenRequestHeaders = [\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"access-control-request-headers\",\n    \"access-control-request-method\",\n    \"connection\",\n    \"content-length\",\n    \"content-transfer-encoding\",\n    \"cookie\",\n    \"cookie2\",\n    \"date\",\n    \"expect\",\n    \"host\",\n    \"keep-alive\",\n    \"origin\",\n    \"referer\",\n    \"te\",\n    \"trailer\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"via\"\n  ];\n\n  // These request methods are not allowed\n  var forbiddenRequestMethods = [\n    \"TRACE\",\n    \"TRACK\",\n    \"CONNECT\"\n  ];\n\n  // Send flag\n  var sendFlag = false;\n  // Error flag, used when errors occur or abort is called\n  var errorFlag = false;\n\n  // Event listeners\n  var listeners = {};\n\n  /**\n   * Constants\n   */\n\n  this.UNSENT = 0;\n  this.OPENED = 1;\n  this.HEADERS_RECEIVED = 2;\n  this.LOADING = 3;\n  this.DONE = 4;\n\n  /**\n   * Public vars\n   */\n\n  // Current state\n  this.readyState = this.UNSENT;\n\n  // default ready state change handler in case one is not set or is set late\n  this.onreadystatechange = null;\n\n  // Result & response\n  this.responseText = \"\";\n  this.responseXML = \"\";\n  this.status = null;\n  this.statusText = null;\n  \n  // Whether cross-site Access-Control requests should be made using\n  // credentials such as cookies or authorization headers\n  this.withCredentials = false;\n\n  /**\n   * Private methods\n   */\n\n  /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpHeader = function(header) {\n    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);\n  };\n\n  /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpMethod = function(method) {\n    return (method && forbiddenRequestMethods.indexOf(method) === -1);\n  };\n\n  /**\n   * Public methods\n   */\n\n  /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */\n  this.open = function(method, url, async, user, password) {\n    this.abort();\n    errorFlag = false;\n\n    // Check for valid request method\n    if (!isAllowedHttpMethod(method)) {\n      throw new Error(\"SecurityError: Request method not allowed\");\n    }\n\n    settings = {\n      \"method\": method,\n      \"url\": url.toString(),\n      \"async\": (typeof async !== \"boolean\" ? true : async),\n      \"user\": user || null,\n      \"password\": password || null\n    };\n\n    setState(this.OPENED);\n  };\n\n  /**\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\n   * This does not conform to the W3C spec.\n   *\n   * @param boolean state Enable or disable header checking.\n   */\n  this.setDisableHeaderCheck = function(state) {\n    disableHeaderCheck = state;\n  };\n\n  /**\n   * Sets a header for the request or appends the value if one is already set.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   */\n  this.setRequestHeader = function(header, value) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\");\n    }\n    if (!isAllowedHttpHeader(header)) {\n      console.warn(\"Refused to set unsafe header \\\"\" + header + \"\\\"\");\n      return;\n    }\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send flag is true\");\n    }\n    header = headersCase[header.toLowerCase()] || header;\n    headersCase[header.toLowerCase()] = header;\n    headers[header] = headers[header] ? headers[header] + ', ' + value : value;\n  };\n\n  /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn't exist.\n   */\n  this.getResponseHeader = function(header) {\n    if (typeof header === \"string\"\n      && this.readyState > this.OPENED\n      && response\n      && response.headers\n      && response.headers[header.toLowerCase()]\n      && !errorFlag\n    ) {\n      return response.headers[header.toLowerCase()];\n    }\n\n    return null;\n  };\n\n  /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */\n  this.getAllResponseHeaders = function() {\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n      return \"\";\n    }\n    var result = \"\";\n\n    for (var i in response.headers) {\n      // Cookie headers are excluded\n      if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n        result += i + \": \" + response.headers[i] + \"\\r\\n\";\n      }\n    }\n    return result.substr(0, result.length - 2);\n  };\n\n  /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */\n  this.getRequestHeader = function(name) {\n    if (typeof name === \"string\" && headersCase[name.toLowerCase()]) {\n      return headers[headersCase[name.toLowerCase()]];\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */\n  this.send = function(data) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: connection must be opened before send() is called\");\n    }\n\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send has already been called\");\n    }\n\n    var ssl = false, local = false;\n    var url = Url.parse(settings.url);\n    var host;\n    // Determine the server\n    switch (url.protocol) {\n      case \"https:\":\n        ssl = true;\n        // SSL & non-SSL both need host, no break here.\n      case \"http:\":\n        host = url.hostname;\n        break;\n\n      case \"file:\":\n        local = true;\n        break;\n\n      case undefined:\n      case null:\n      case \"\":\n        host = \"localhost\";\n        break;\n\n      default:\n        throw new Error(\"Protocol not supported.\");\n    }\n\n    // Load files off the local filesystem (file://)\n    if (local) {\n      if (settings.method !== \"GET\") {\n        throw new Error(\"XMLHttpRequest: Only GET method is supported\");\n      }\n\n      if (settings.async) {\n        fs.readFile(url.pathname, \"utf8\", function(error, data) {\n          if (error) {\n            self.handleError(error);\n          } else {\n            self.status = 200;\n            self.responseText = data;\n            setState(self.DONE);\n          }\n        });\n      } else {\n        try {\n          this.responseText = fs.readFileSync(url.pathname, \"utf8\");\n          this.status = 200;\n          setState(self.DONE);\n        } catch(e) {\n          this.handleError(e);\n        }\n      }\n\n      return;\n    }\n\n    // Default to port 80. If accessing localhost on another port be sure\n    // to use http://localhost:port/path\n    var port = url.port || (ssl ? 443 : 80);\n    // Add query string if one is used\n    var uri = url.pathname + (url.search ? url.search : \"\");\n\n    // Set the defaults if they haven't been set\n    for (var name in defaultHeaders) {\n      if (!headersCase[name.toLowerCase()]) {\n        headers[name] = defaultHeaders[name];\n      }\n    }\n\n    // Set the Host header or the server may reject the request\n    headers.Host = host;\n    if (!((ssl && port === 443) || port === 80)) {\n      headers.Host += \":\" + url.port;\n    }\n\n    // Set Basic Auth if necessary\n    if (settings.user) {\n      if (typeof settings.password === \"undefined\") {\n        settings.password = \"\";\n      }\n      var authBuf = new Buffer(settings.user + \":\" + settings.password);\n      headers.Authorization = \"Basic \" + authBuf.toString(\"base64\");\n    }\n\n    // Set content length header\n    if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n      data = null;\n    } else if (data) {\n      headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\n\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n    } else if (settings.method === \"POST\") {\n      // For a post with no data set Content-Length: 0.\n      // This is required by buggy servers that don't meet the specs.\n      headers[\"Content-Length\"] = 0;\n    }\n\n    var options = {\n      host: host,\n      port: port,\n      path: uri,\n      method: settings.method,\n      headers: headers,\n      agent: false,\n      withCredentials: self.withCredentials\n    };\n\n    // Reset error flag\n    errorFlag = false;\n\n    // Handle async requests\n    if (settings.async) {\n      // Use the proper protocol\n      var doRequest = ssl ? https.request : http.request;\n\n      // Request is being sent, set send flag\n      sendFlag = true;\n\n      // As per spec, this is called here for historical reasons.\n      self.dispatchEvent(\"readystatechange\");\n\n      // Handler for the response\n      var responseHandler = function responseHandler(resp) {\n        // Set response var to the response we got back\n        // This is so it remains accessable outside this scope\n        response = resp;\n        // Check for redirect\n        // @TODO Prevent looped redirects\n        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\n          // Change URL to the redirect location\n          settings.url = response.headers.location;\n          var url = Url.parse(settings.url);\n          // Set host var in case it's used later\n          host = url.hostname;\n          // Options for the new request\n          var newOptions = {\n            hostname: url.hostname,\n            port: url.port,\n            path: url.path,\n            method: response.statusCode === 303 ? \"GET\" : settings.method,\n            headers: headers,\n            withCredentials: self.withCredentials\n          };\n\n          // Issue the new request\n          request = doRequest(newOptions, responseHandler).on(\"error\", errorHandler);\n          request.end();\n          // @TODO Check if an XHR event needs to be fired here\n          return;\n        }\n\n        response.setEncoding(\"utf8\");\n\n        setState(self.HEADERS_RECEIVED);\n        self.status = response.statusCode;\n\n        response.on(\"data\", function(chunk) {\n          // Make sure there's some data\n          if (chunk) {\n            self.responseText += chunk;\n          }\n          // Don't emit state changes if the connection has been aborted.\n          if (sendFlag) {\n            setState(self.LOADING);\n          }\n        });\n\n        response.on(\"end\", function() {\n          if (sendFlag) {\n            // Discard the end event if the connection has been aborted\n            setState(self.DONE);\n            sendFlag = false;\n          }\n        });\n\n        response.on(\"error\", function(error) {\n          self.handleError(error);\n        });\n      };\n\n      // Error handler for the request\n      var errorHandler = function errorHandler(error) {\n        self.handleError(error);\n      };\n\n      // Create the request\n      request = doRequest(options, responseHandler).on(\"error\", errorHandler);\n\n      // Node 0.4 and later won't accept empty data. Make sure it's needed.\n      if (data) {\n        request.write(data);\n      }\n\n      request.end();\n\n      self.dispatchEvent(\"loadstart\");\n    } else { // Synchronous\n      // Create a temporary file for communication with the other Node process\n      var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\n      var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n      fs.writeFileSync(syncFile, \"\", \"utf8\");\n      // The async request the other Node process executes\n      var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\"\n        + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\"\n        + \"var options = \" + JSON.stringify(options) + \";\"\n        + \"var responseText = '';\"\n        + \"var req = doRequest(options, function(response) {\"\n        + \"response.setEncoding('utf8');\"\n        + \"response.on('data', function(chunk) {\"\n        + \"  responseText += chunk;\"\n        + \"});\"\n        + \"response.on('end', function() {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + \"response.on('error', function(error) {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: error}), 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + \"}).on('error', function(error) {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: error}), 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + (data ? \"req.write('\" + JSON.stringify(data).slice(1,-1).replace(/'/g, \"\\\\'\") + \"');\":\"\")\n        + \"req.end();\";\n      // Start the other Node Process, executing this string\n      var syncProc = spawn(process.argv[0], [\"-e\", execString]);\n      while(fs.existsSync(syncFile)) {\n        // Wait while the sync file is empty\n      }\n      var resp = JSON.parse(fs.readFileSync(contentFile, 'utf8'));\n      // Kill the child process once the file has data\n      syncProc.stdin.end();\n      // Remove the temporary file\n      fs.unlinkSync(contentFile);\n\n      if (resp.err) {\n        self.handleError(resp.err);\n      } else {\n        response = resp.data;\n        self.status = resp.data.statusCode;\n        self.responseText = resp.data.text;\n        setState(self.DONE);\n      }\n    }\n  };\n\n  /**\n   * Called when an error is encountered to deal with it.\n   */\n  this.handleError = function(error) {\n    this.status = 0;\n    this.statusText = error;\n    this.responseText = error.stack;\n    errorFlag = true;\n    setState(this.DONE);\n    this.dispatchEvent('error');\n  };\n\n  /**\n   * Aborts a request.\n   */\n  this.abort = function() {\n    if (request) {\n      request.abort();\n      request = null;\n    }\n\n    headers = defaultHeaders;\n    this.status = 0;\n    this.responseText = \"\";\n    this.responseXML = \"\";\n\n    errorFlag = true;\n\n    if (this.readyState !== this.UNSENT\n        && (this.readyState !== this.OPENED || sendFlag)\n        && this.readyState !== this.DONE) {\n      sendFlag = false;\n      setState(this.DONE);\n    }\n    this.readyState = this.UNSENT;\n    this.dispatchEvent('abort');\n  };\n\n  /**\n   * Adds an event listener. Preferred method of binding to events.\n   */\n  this.addEventListener = function(event, callback) {\n    if (!(event in listeners)) {\n      listeners[event] = [];\n    }\n    // Currently allows duplicate callbacks. Should it?\n    listeners[event].push(callback);\n  };\n\n  /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */\n  this.removeEventListener = function(event, callback) {\n    if (event in listeners) {\n      // Filter will return a new array with the callback removed\n      listeners[event] = listeners[event].filter(function(ev) {\n        return ev !== callback;\n      });\n    }\n  };\n\n  /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */\n  this.dispatchEvent = function(event) {\n    if (typeof self[\"on\" + event] === \"function\") {\n      self[\"on\" + event]();\n    }\n    if (event in listeners) {\n      for (var i = 0, len = listeners[event].length; i < len; i++) {\n        listeners[event][i].call(self);\n      }\n    }\n  };\n\n  /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */\n  var setState = function(state) {\n    if (state == self.LOADING || self.readyState !== state) {\n      self.readyState = state;\n\n      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n        self.dispatchEvent(\"readystatechange\");\n      }\n\n      if (self.readyState === self.DONE && !errorFlag) {\n        self.dispatchEvent(\"load\");\n        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n        self.dispatchEvent(\"loadend\");\n      }\n    }\n  };\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,KAAK,CAAC;AACxB,IAAIC,KAAK,GAAGD,OAAO,CAAC,eAAe,CAAC,CAACC,KAAK;AAC1C,IAAIC,EAAE,GAAGF,OAAO,CAAC,IAAI,CAAC;AAEtBG,OAAO,CAACC,cAAc,GAAG,YAAW;EAClC,YAAY;;EAEZ;AACF;AACA;EACE,IAAIC,IAAI,GAAG,IAAI;EACf,IAAIC,IAAI,GAAGN,OAAO,CAAC,MAAM,CAAC;EAC1B,IAAIO,KAAK,GAAGP,OAAO,CAAC,OAAO,CAAC;;EAE5B;EACA,IAAIQ,OAAO;EACX,IAAIC,QAAQ;;EAEZ;EACA,IAAIC,QAAQ,GAAG,CAAC,CAAC;;EAEjB;EACA;EACA,IAAIC,kBAAkB,GAAG,KAAK;;EAE9B;EACA,IAAIC,cAAc,GAAG;IACnB,YAAY,EAAE,qBAAqB;IACnC,QAAQ,EAAE;EACZ,CAAC;EAED,IAAIC,OAAO,GAAG,CAAC,CAAC;EAChB,IAAIC,WAAW,GAAG,CAAC,CAAC;;EAEpB;EACA;EACA;EACA,IAAIC,uBAAuB,GAAG,CAC5B,gBAAgB,EAChB,iBAAiB,EACjB,gCAAgC,EAChC,+BAA+B,EAC/B,YAAY,EACZ,gBAAgB,EAChB,2BAA2B,EAC3B,QAAQ,EACR,SAAS,EACT,MAAM,EACN,QAAQ,EACR,MAAM,EACN,YAAY,EACZ,QAAQ,EACR,SAAS,EACT,IAAI,EACJ,SAAS,EACT,mBAAmB,EACnB,SAAS,EACT,KAAK,CACN;;EAED;EACA,IAAIC,uBAAuB,GAAG,CAC5B,OAAO,EACP,OAAO,EACP,SAAS,CACV;;EAED;EACA,IAAIC,QAAQ,GAAG,KAAK;EACpB;EACA,IAAIC,SAAS,GAAG,KAAK;;EAErB;EACA,IAAIC,SAAS,GAAG,CAAC,CAAC;;EAElB;AACF;AACA;;EAEE,IAAI,CAACC,MAAM,GAAG,CAAC;EACf,IAAI,CAACC,MAAM,GAAG,CAAC;EACf,IAAI,CAACC,gBAAgB,GAAG,CAAC;EACzB,IAAI,CAACC,OAAO,GAAG,CAAC;EAChB,IAAI,CAACC,IAAI,GAAG,CAAC;;EAEb;AACF;AACA;;EAEE;EACA,IAAI,CAACC,UAAU,GAAG,IAAI,CAACL,MAAM;;EAE7B;EACA,IAAI,CAACM,kBAAkB,GAAG,IAAI;;EAE9B;EACA,IAAI,CAACC,YAAY,GAAG,EAAE;EACtB,IAAI,CAACC,WAAW,GAAG,EAAE;EACrB,IAAI,CAACC,MAAM,GAAG,IAAI;EAClB,IAAI,CAACC,UAAU,GAAG,IAAI;;EAEtB;EACA;EACA,IAAI,CAACC,eAAe,GAAG,KAAK;;EAE5B;AACF;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;EACE,IAAIC,mBAAmB,GAAG,SAAAA,CAASC,MAAM,EAAE;IACzC,OAAOtB,kBAAkB,IAAKsB,MAAM,IAAIlB,uBAAuB,CAACmB,OAAO,CAACD,MAAM,CAACE,WAAW,CAAC,CAAC,CAAC,KAAK,CAAC,CAAE;EACvG,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,IAAIC,mBAAmB,GAAG,SAAAA,CAASC,MAAM,EAAE;IACzC,OAAQA,MAAM,IAAIrB,uBAAuB,CAACkB,OAAO,CAACG,MAAM,CAAC,KAAK,CAAC,CAAC;EAClE,CAAC;;EAED;AACF;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,IAAI,GAAG,UAASD,MAAM,EAAEE,GAAG,EAAEC,KAAK,EAAEC,IAAI,EAAEC,QAAQ,EAAE;IACvD,IAAI,CAACC,KAAK,CAAC,CAAC;IACZzB,SAAS,GAAG,KAAK;;IAEjB;IACA,IAAI,CAACkB,mBAAmB,CAACC,MAAM,CAAC,EAAE;MAChC,MAAM,IAAIO,KAAK,CAAC,2CAA2C,CAAC;IAC9D;IAEAlC,QAAQ,GAAG;MACT,QAAQ,EAAE2B,MAAM;MAChB,KAAK,EAAEE,GAAG,CAACM,QAAQ,CAAC,CAAC;MACrB,OAAO,EAAG,OAAOL,KAAK,KAAK,SAAS,GAAG,IAAI,GAAGA,KAAM;MACpD,MAAM,EAAEC,IAAI,IAAI,IAAI;MACpB,UAAU,EAAEC,QAAQ,IAAI;IAC1B,CAAC;IAEDI,QAAQ,CAAC,IAAI,CAACzB,MAAM,CAAC;EACvB,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAAC0B,qBAAqB,GAAG,UAASC,KAAK,EAAE;IAC3CrC,kBAAkB,GAAGqC,KAAK;EAC5B,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,gBAAgB,GAAG,UAAShB,MAAM,EAAEiB,KAAK,EAAE;IAC9C,IAAI,IAAI,CAACzB,UAAU,KAAK,IAAI,CAACJ,MAAM,EAAE;MACnC,MAAM,IAAIuB,KAAK,CAAC,2EAA2E,CAAC;IAC9F;IACA,IAAI,CAACZ,mBAAmB,CAACC,MAAM,CAAC,EAAE;MAChCkB,OAAO,CAACC,IAAI,CAAC,iCAAiC,GAAGnB,MAAM,GAAG,IAAI,CAAC;MAC/D;IACF;IACA,IAAIhB,QAAQ,EAAE;MACZ,MAAM,IAAI2B,KAAK,CAAC,sCAAsC,CAAC;IACzD;IACAX,MAAM,GAAGnB,WAAW,CAACmB,MAAM,CAACE,WAAW,CAAC,CAAC,CAAC,IAAIF,MAAM;IACpDnB,WAAW,CAACmB,MAAM,CAACE,WAAW,CAAC,CAAC,CAAC,GAAGF,MAAM;IAC1CpB,OAAO,CAACoB,MAAM,CAAC,GAAGpB,OAAO,CAACoB,MAAM,CAAC,GAAGpB,OAAO,CAACoB,MAAM,CAAC,GAAG,IAAI,GAAGiB,KAAK,GAAGA,KAAK;EAC5E,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACG,iBAAiB,GAAG,UAASpB,MAAM,EAAE;IACxC,IAAI,OAAOA,MAAM,KAAK,QAAQ,IACzB,IAAI,CAACR,UAAU,GAAG,IAAI,CAACJ,MAAM,IAC7BZ,QAAQ,IACRA,QAAQ,CAACI,OAAO,IAChBJ,QAAQ,CAACI,OAAO,CAACoB,MAAM,CAACE,WAAW,CAAC,CAAC,CAAC,IACtC,CAACjB,SAAS,EACb;MACA,OAAOT,QAAQ,CAACI,OAAO,CAACoB,MAAM,CAACE,WAAW,CAAC,CAAC,CAAC;IAC/C;IAEA,OAAO,IAAI;EACb,CAAC;;EAED;AACF;AACA;AACA;AACA;EACE,IAAI,CAACmB,qBAAqB,GAAG,YAAW;IACtC,IAAI,IAAI,CAAC7B,UAAU,GAAG,IAAI,CAACH,gBAAgB,IAAIJ,SAAS,EAAE;MACxD,OAAO,EAAE;IACX;IACA,IAAIqC,MAAM,GAAG,EAAE;IAEf,KAAK,IAAIC,CAAC,IAAI/C,QAAQ,CAACI,OAAO,EAAE;MAC9B;MACA,IAAI2C,CAAC,KAAK,YAAY,IAAIA,CAAC,KAAK,aAAa,EAAE;QAC7CD,MAAM,IAAIC,CAAC,GAAG,IAAI,GAAG/C,QAAQ,CAACI,OAAO,CAAC2C,CAAC,CAAC,GAAG,MAAM;MACnD;IACF;IACA,OAAOD,MAAM,CAACE,MAAM,CAAC,CAAC,EAAEF,MAAM,CAACG,MAAM,GAAG,CAAC,CAAC;EAC5C,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,gBAAgB,GAAG,UAASC,IAAI,EAAE;IACrC,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAI9C,WAAW,CAAC8C,IAAI,CAACzB,WAAW,CAAC,CAAC,CAAC,EAAE;MAC/D,OAAOtB,OAAO,CAACC,WAAW,CAAC8C,IAAI,CAACzB,WAAW,CAAC,CAAC,CAAC,CAAC;IACjD;IAEA,OAAO,EAAE;EACX,CAAC;;EAED;AACF;AACA;AACA;AACA;EACE,IAAI,CAAC0B,IAAI,GAAG,UAASC,IAAI,EAAE;IACzB,IAAI,IAAI,CAACrC,UAAU,KAAK,IAAI,CAACJ,MAAM,EAAE;MACnC,MAAM,IAAIuB,KAAK,CAAC,sEAAsE,CAAC;IACzF;IAEA,IAAI3B,QAAQ,EAAE;MACZ,MAAM,IAAI2B,KAAK,CAAC,iDAAiD,CAAC;IACpE;IAEA,IAAImB,GAAG,GAAG,KAAK;MAAEC,KAAK,GAAG,KAAK;IAC9B,IAAIzB,GAAG,GAAGxC,GAAG,CAACkE,KAAK,CAACvD,QAAQ,CAAC6B,GAAG,CAAC;IACjC,IAAI2B,IAAI;IACR;IACA,QAAQ3B,GAAG,CAAC4B,QAAQ;MAClB,KAAK,QAAQ;QACXJ,GAAG,GAAG,IAAI;MACV;MACF,KAAK,OAAO;QACVG,IAAI,GAAG3B,GAAG,CAAC6B,QAAQ;QACnB;MAEF,KAAK,OAAO;QACVJ,KAAK,GAAG,IAAI;QACZ;MAEF,KAAKK,SAAS;MACd,KAAK,IAAI;MACT,KAAK,EAAE;QACLH,IAAI,GAAG,WAAW;QAClB;MAEF;QACE,MAAM,IAAItB,KAAK,CAAC,yBAAyB,CAAC;IAC9C;;IAEA;IACA,IAAIoB,KAAK,EAAE;MACT,IAAItD,QAAQ,CAAC2B,MAAM,KAAK,KAAK,EAAE;QAC7B,MAAM,IAAIO,KAAK,CAAC,8CAA8C,CAAC;MACjE;MAEA,IAAIlC,QAAQ,CAAC8B,KAAK,EAAE;QAClBtC,EAAE,CAACoE,QAAQ,CAAC/B,GAAG,CAACgC,QAAQ,EAAE,MAAM,EAAE,UAASC,KAAK,EAAEV,IAAI,EAAE;UACtD,IAAIU,KAAK,EAAE;YACTnE,IAAI,CAACoE,WAAW,CAACD,KAAK,CAAC;UACzB,CAAC,MAAM;YACLnE,IAAI,CAACwB,MAAM,GAAG,GAAG;YACjBxB,IAAI,CAACsB,YAAY,GAAGmC,IAAI;YACxBhB,QAAQ,CAACzC,IAAI,CAACmB,IAAI,CAAC;UACrB;QACF,CAAC,CAAC;MACJ,CAAC,MAAM;QACL,IAAI;UACF,IAAI,CAACG,YAAY,GAAGzB,EAAE,CAACwE,YAAY,CAACnC,GAAG,CAACgC,QAAQ,EAAE,MAAM,CAAC;UACzD,IAAI,CAAC1C,MAAM,GAAG,GAAG;UACjBiB,QAAQ,CAACzC,IAAI,CAACmB,IAAI,CAAC;QACrB,CAAC,CAAC,OAAMmD,CAAC,EAAE;UACT,IAAI,CAACF,WAAW,CAACE,CAAC,CAAC;QACrB;MACF;MAEA;IACF;;IAEA;IACA;IACA,IAAIC,IAAI,GAAGrC,GAAG,CAACqC,IAAI,KAAKb,GAAG,GAAG,GAAG,GAAG,EAAE,CAAC;IACvC;IACA,IAAIc,GAAG,GAAGtC,GAAG,CAACgC,QAAQ,IAAIhC,GAAG,CAACuC,MAAM,GAAGvC,GAAG,CAACuC,MAAM,GAAG,EAAE,CAAC;;IAEvD;IACA,KAAK,IAAIlB,IAAI,IAAIhD,cAAc,EAAE;MAC/B,IAAI,CAACE,WAAW,CAAC8C,IAAI,CAACzB,WAAW,CAAC,CAAC,CAAC,EAAE;QACpCtB,OAAO,CAAC+C,IAAI,CAAC,GAAGhD,cAAc,CAACgD,IAAI,CAAC;MACtC;IACF;;IAEA;IACA/C,OAAO,CAACkE,IAAI,GAAGb,IAAI;IACnB,IAAI,EAAGH,GAAG,IAAIa,IAAI,KAAK,GAAG,IAAKA,IAAI,KAAK,EAAE,CAAC,EAAE;MAC3C/D,OAAO,CAACkE,IAAI,IAAI,GAAG,GAAGxC,GAAG,CAACqC,IAAI;IAChC;;IAEA;IACA,IAAIlE,QAAQ,CAAC+B,IAAI,EAAE;MACjB,IAAI,OAAO/B,QAAQ,CAACgC,QAAQ,KAAK,WAAW,EAAE;QAC5ChC,QAAQ,CAACgC,QAAQ,GAAG,EAAE;MACxB;MACA,IAAIsC,OAAO,GAAG,IAAIC,MAAM,CAACvE,QAAQ,CAAC+B,IAAI,GAAG,GAAG,GAAG/B,QAAQ,CAACgC,QAAQ,CAAC;MACjE7B,OAAO,CAACqE,aAAa,GAAG,QAAQ,GAAGF,OAAO,CAACnC,QAAQ,CAAC,QAAQ,CAAC;IAC/D;;IAEA;IACA,IAAInC,QAAQ,CAAC2B,MAAM,KAAK,KAAK,IAAI3B,QAAQ,CAAC2B,MAAM,KAAK,MAAM,EAAE;MAC3DyB,IAAI,GAAG,IAAI;IACb,CAAC,MAAM,IAAIA,IAAI,EAAE;MACfjD,OAAO,CAAC,gBAAgB,CAAC,GAAGoE,MAAM,CAACE,QAAQ,CAACrB,IAAI,CAAC,GAAGA,IAAI,CAACJ,MAAM,GAAGuB,MAAM,CAACG,UAAU,CAACtB,IAAI,CAAC;MAEzF,IAAI,CAACjD,OAAO,CAAC,cAAc,CAAC,EAAE;QAC5BA,OAAO,CAAC,cAAc,CAAC,GAAG,0BAA0B;MACtD;IACF,CAAC,MAAM,IAAIH,QAAQ,CAAC2B,MAAM,KAAK,MAAM,EAAE;MACrC;MACA;MACAxB,OAAO,CAAC,gBAAgB,CAAC,GAAG,CAAC;IAC/B;IAEA,IAAIwE,OAAO,GAAG;MACZnB,IAAI,EAAEA,IAAI;MACVU,IAAI,EAAEA,IAAI;MACVU,IAAI,EAAET,GAAG;MACTxC,MAAM,EAAE3B,QAAQ,CAAC2B,MAAM;MACvBxB,OAAO,EAAEA,OAAO;MAChB0E,KAAK,EAAE,KAAK;MACZxD,eAAe,EAAE1B,IAAI,CAAC0B;IACxB,CAAC;;IAED;IACAb,SAAS,GAAG,KAAK;;IAEjB;IACA,IAAIR,QAAQ,CAAC8B,KAAK,EAAE;MAClB;MACA,IAAIgD,SAAS,GAAGzB,GAAG,GAAGxD,KAAK,CAACC,OAAO,GAAGF,IAAI,CAACE,OAAO;;MAElD;MACAS,QAAQ,GAAG,IAAI;;MAEf;MACAZ,IAAI,CAACoF,aAAa,CAAC,kBAAkB,CAAC;;MAEtC;MACA,IAAIC,eAAe,GAAG,SAASA,eAAeA,CAACC,IAAI,EAAE;QACnD;QACA;QACAlF,QAAQ,GAAGkF,IAAI;QACf;QACA;QACA,IAAIlF,QAAQ,CAACmF,UAAU,KAAK,GAAG,IAAInF,QAAQ,CAACmF,UAAU,KAAK,GAAG,IAAInF,QAAQ,CAACmF,UAAU,KAAK,GAAG,IAAInF,QAAQ,CAACmF,UAAU,KAAK,GAAG,EAAE;UAC5H;UACAlF,QAAQ,CAAC6B,GAAG,GAAG9B,QAAQ,CAACI,OAAO,CAACgF,QAAQ;UACxC,IAAItD,GAAG,GAAGxC,GAAG,CAACkE,KAAK,CAACvD,QAAQ,CAAC6B,GAAG,CAAC;UACjC;UACA2B,IAAI,GAAG3B,GAAG,CAAC6B,QAAQ;UACnB;UACA,IAAI0B,UAAU,GAAG;YACf1B,QAAQ,EAAE7B,GAAG,CAAC6B,QAAQ;YACtBQ,IAAI,EAAErC,GAAG,CAACqC,IAAI;YACdU,IAAI,EAAE/C,GAAG,CAAC+C,IAAI;YACdjD,MAAM,EAAE5B,QAAQ,CAACmF,UAAU,KAAK,GAAG,GAAG,KAAK,GAAGlF,QAAQ,CAAC2B,MAAM;YAC7DxB,OAAO,EAAEA,OAAO;YAChBkB,eAAe,EAAE1B,IAAI,CAAC0B;UACxB,CAAC;;UAED;UACAvB,OAAO,GAAGgF,SAAS,CAACM,UAAU,EAAEJ,eAAe,CAAC,CAACK,EAAE,CAAC,OAAO,EAAEC,YAAY,CAAC;UAC1ExF,OAAO,CAACyF,GAAG,CAAC,CAAC;UACb;UACA;QACF;QAEAxF,QAAQ,CAACyF,WAAW,CAAC,MAAM,CAAC;QAE5BpD,QAAQ,CAACzC,IAAI,CAACiB,gBAAgB,CAAC;QAC/BjB,IAAI,CAACwB,MAAM,GAAGpB,QAAQ,CAACmF,UAAU;QAEjCnF,QAAQ,CAACsF,EAAE,CAAC,MAAM,EAAE,UAASI,KAAK,EAAE;UAClC;UACA,IAAIA,KAAK,EAAE;YACT9F,IAAI,CAACsB,YAAY,IAAIwE,KAAK;UAC5B;UACA;UACA,IAAIlF,QAAQ,EAAE;YACZ6B,QAAQ,CAACzC,IAAI,CAACkB,OAAO,CAAC;UACxB;QACF,CAAC,CAAC;QAEFd,QAAQ,CAACsF,EAAE,CAAC,KAAK,EAAE,YAAW;UAC5B,IAAI9E,QAAQ,EAAE;YACZ;YACA6B,QAAQ,CAACzC,IAAI,CAACmB,IAAI,CAAC;YACnBP,QAAQ,GAAG,KAAK;UAClB;QACF,CAAC,CAAC;QAEFR,QAAQ,CAACsF,EAAE,CAAC,OAAO,EAAE,UAASvB,KAAK,EAAE;UACnCnE,IAAI,CAACoE,WAAW,CAACD,KAAK,CAAC;QACzB,CAAC,CAAC;MACJ,CAAC;;MAED;MACA,IAAIwB,YAAY,GAAG,SAASA,YAAYA,CAACxB,KAAK,EAAE;QAC9CnE,IAAI,CAACoE,WAAW,CAACD,KAAK,CAAC;MACzB,CAAC;;MAED;MACAhE,OAAO,GAAGgF,SAAS,CAACH,OAAO,EAAEK,eAAe,CAAC,CAACK,EAAE,CAAC,OAAO,EAAEC,YAAY,CAAC;;MAEvE;MACA,IAAIlC,IAAI,EAAE;QACRtD,OAAO,CAAC4F,KAAK,CAACtC,IAAI,CAAC;MACrB;MAEAtD,OAAO,CAACyF,GAAG,CAAC,CAAC;MAEb5F,IAAI,CAACoF,aAAa,CAAC,WAAW,CAAC;IACjC,CAAC,MAAM;MAAE;MACP;MACA,IAAIY,WAAW,GAAG,+BAA+B,GAAGC,OAAO,CAACC,GAAG;MAC/D,IAAIC,QAAQ,GAAG,4BAA4B,GAAGF,OAAO,CAACC,GAAG;MACzDrG,EAAE,CAACuG,aAAa,CAACD,QAAQ,EAAE,EAAE,EAAE,MAAM,CAAC;MACtC;MACA,IAAIE,UAAU,GAAG,2EAA2E,GACxF,sBAAsB,IAAI3C,GAAG,GAAG,GAAG,GAAG,EAAE,CAAC,GAAG,WAAW,GACvD,gBAAgB,GAAG4C,IAAI,CAACC,SAAS,CAACvB,OAAO,CAAC,GAAG,GAAG,GAChD,wBAAwB,GACxB,mDAAmD,GACnD,+BAA+B,GAC/B,uCAAuC,GACvC,0BAA0B,GAC1B,KAAK,GACL,iCAAiC,GACjC,oBAAoB,GAAGgB,WAAW,GAAG,kIAAkI,GACvK,iBAAiB,GAAGG,QAAQ,GAAG,KAAK,GACpC,KAAK,GACL,wCAAwC,GACxC,oBAAoB,GAAGH,WAAW,GAAG,2CAA2C,GAChF,iBAAiB,GAAGG,QAAQ,GAAG,KAAK,GACpC,KAAK,GACL,kCAAkC,GAClC,oBAAoB,GAAGH,WAAW,GAAG,2CAA2C,GAChF,iBAAiB,GAAGG,QAAQ,GAAG,KAAK,GACpC,KAAK,IACJ1C,IAAI,GAAG,aAAa,GAAG6C,IAAI,CAACC,SAAS,CAAC9C,IAAI,CAAC,CAAC+C,KAAK,CAAC,CAAC,EAAC,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,KAAK,GAAC,EAAE,CAAC,GACzF,YAAY;MAChB;MACA,IAAIC,QAAQ,GAAG9G,KAAK,CAACqG,OAAO,CAACU,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,EAAEN,UAAU,CAAC,CAAC;MACzD,OAAMxG,EAAE,CAAC+G,UAAU,CAACT,QAAQ,CAAC,EAAE;QAC7B;MAAA;MAEF,IAAIb,IAAI,GAAGgB,IAAI,CAAC1C,KAAK,CAAC/D,EAAE,CAACwE,YAAY,CAAC2B,WAAW,EAAE,MAAM,CAAC,CAAC;MAC3D;MACAU,QAAQ,CAACG,KAAK,CAACjB,GAAG,CAAC,CAAC;MACpB;MACA/F,EAAE,CAACiH,UAAU,CAACd,WAAW,CAAC;MAE1B,IAAIV,IAAI,CAACyB,GAAG,EAAE;QACZ/G,IAAI,CAACoE,WAAW,CAACkB,IAAI,CAACyB,GAAG,CAAC;MAC5B,CAAC,MAAM;QACL3G,QAAQ,GAAGkF,IAAI,CAAC7B,IAAI;QACpBzD,IAAI,CAACwB,MAAM,GAAG8D,IAAI,CAAC7B,IAAI,CAAC8B,UAAU;QAClCvF,IAAI,CAACsB,YAAY,GAAGgE,IAAI,CAAC7B,IAAI,CAACuD,IAAI;QAClCvE,QAAQ,CAACzC,IAAI,CAACmB,IAAI,CAAC;MACrB;IACF;EACF,CAAC;;EAED;AACF;AACA;EACE,IAAI,CAACiD,WAAW,GAAG,UAASD,KAAK,EAAE;IACjC,IAAI,CAAC3C,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,UAAU,GAAG0C,KAAK;IACvB,IAAI,CAAC7C,YAAY,GAAG6C,KAAK,CAAC8C,KAAK;IAC/BpG,SAAS,GAAG,IAAI;IAChB4B,QAAQ,CAAC,IAAI,CAACtB,IAAI,CAAC;IACnB,IAAI,CAACiE,aAAa,CAAC,OAAO,CAAC;EAC7B,CAAC;;EAED;AACF;AACA;EACE,IAAI,CAAC9C,KAAK,GAAG,YAAW;IACtB,IAAInC,OAAO,EAAE;MACXA,OAAO,CAACmC,KAAK,CAAC,CAAC;MACfnC,OAAO,GAAG,IAAI;IAChB;IAEAK,OAAO,GAAGD,cAAc;IACxB,IAAI,CAACiB,MAAM,GAAG,CAAC;IACf,IAAI,CAACF,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,WAAW,GAAG,EAAE;IAErBV,SAAS,GAAG,IAAI;IAEhB,IAAI,IAAI,CAACO,UAAU,KAAK,IAAI,CAACL,MAAM,KAC3B,IAAI,CAACK,UAAU,KAAK,IAAI,CAACJ,MAAM,IAAIJ,QAAQ,CAAC,IAC7C,IAAI,CAACQ,UAAU,KAAK,IAAI,CAACD,IAAI,EAAE;MACpCP,QAAQ,GAAG,KAAK;MAChB6B,QAAQ,CAAC,IAAI,CAACtB,IAAI,CAAC;IACrB;IACA,IAAI,CAACC,UAAU,GAAG,IAAI,CAACL,MAAM;IAC7B,IAAI,CAACqE,aAAa,CAAC,OAAO,CAAC;EAC7B,CAAC;;EAED;AACF;AACA;EACE,IAAI,CAAC8B,gBAAgB,GAAG,UAASC,KAAK,EAAEC,QAAQ,EAAE;IAChD,IAAI,EAAED,KAAK,IAAIrG,SAAS,CAAC,EAAE;MACzBA,SAAS,CAACqG,KAAK,CAAC,GAAG,EAAE;IACvB;IACA;IACArG,SAAS,CAACqG,KAAK,CAAC,CAACE,IAAI,CAACD,QAAQ,CAAC;EACjC,CAAC;;EAED;AACF;AACA;AACA;EACE,IAAI,CAACE,mBAAmB,GAAG,UAASH,KAAK,EAAEC,QAAQ,EAAE;IACnD,IAAID,KAAK,IAAIrG,SAAS,EAAE;MACtB;MACAA,SAAS,CAACqG,KAAK,CAAC,GAAGrG,SAAS,CAACqG,KAAK,CAAC,CAACI,MAAM,CAAC,UAASC,EAAE,EAAE;QACtD,OAAOA,EAAE,KAAKJ,QAAQ;MACxB,CAAC,CAAC;IACJ;EACF,CAAC;;EAED;AACF;AACA;EACE,IAAI,CAAChC,aAAa,GAAG,UAAS+B,KAAK,EAAE;IACnC,IAAI,OAAOnH,IAAI,CAAC,IAAI,GAAGmH,KAAK,CAAC,KAAK,UAAU,EAAE;MAC5CnH,IAAI,CAAC,IAAI,GAAGmH,KAAK,CAAC,CAAC,CAAC;IACtB;IACA,IAAIA,KAAK,IAAIrG,SAAS,EAAE;MACtB,KAAK,IAAIqC,CAAC,GAAG,CAAC,EAAEsE,GAAG,GAAG3G,SAAS,CAACqG,KAAK,CAAC,CAAC9D,MAAM,EAAEF,CAAC,GAAGsE,GAAG,EAAEtE,CAAC,EAAE,EAAE;QAC3DrC,SAAS,CAACqG,KAAK,CAAC,CAAChE,CAAC,CAAC,CAACuE,IAAI,CAAC1H,IAAI,CAAC;MAChC;IACF;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;EACE,IAAIyC,QAAQ,GAAG,SAAAA,CAASE,KAAK,EAAE;IAC7B,IAAIA,KAAK,IAAI3C,IAAI,CAACkB,OAAO,IAAIlB,IAAI,CAACoB,UAAU,KAAKuB,KAAK,EAAE;MACtD3C,IAAI,CAACoB,UAAU,GAAGuB,KAAK;MAEvB,IAAItC,QAAQ,CAAC8B,KAAK,IAAInC,IAAI,CAACoB,UAAU,GAAGpB,IAAI,CAACgB,MAAM,IAAIhB,IAAI,CAACoB,UAAU,KAAKpB,IAAI,CAACmB,IAAI,EAAE;QACpFnB,IAAI,CAACoF,aAAa,CAAC,kBAAkB,CAAC;MACxC;MAEA,IAAIpF,IAAI,CAACoB,UAAU,KAAKpB,IAAI,CAACmB,IAAI,IAAI,CAACN,SAAS,EAAE;QAC/Cb,IAAI,CAACoF,aAAa,CAAC,MAAM,CAAC;QAC1B;QACApF,IAAI,CAACoF,aAAa,CAAC,SAAS,CAAC;MAC/B;IACF;EACF,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}